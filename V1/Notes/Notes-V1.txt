Java:
-----

30-MAY-2023
-----------

Processor is Hardware which understands only Binary numbers (0,1)

User instruction -> Calculator -> OS -> Processor
User instruction -> calculator -> OS System Routines -> Commands -> ZEROs and ONEs

Processor - 
Low level or Machine language - ZEROs and ONEs
Middle level or Assembly language - Commands
	Commands: add 2 2 , sub 2 2

OS -
System routines

Binary:
0 1 -> 0 1 2 3 4

0 - 0 0
1 - 0 1
2 - 1 0
3 - 1 1
4 - 1 0 0
8 - 1 0 0 0

2 power 0
2 power 1
2 power 2

Octal:
8 power 0
8 power 1
8 power 2

Decimal:
10 power 0
10 power 1
10 power 2

HexaDecimal:
16 power 0
16 power 1
16 power 2

0 15
0 .. 9 a b .. f


31-MAY-2023
-----------

Programing languages:
Java
C
C++
C#
SQL
Java-script

Java Programing Language:

What is Java?

Java is a High Level Programing Language

	High Level: Simple english like statements [object1.addAndPrint()]

	Simple english like statements -> OS -> Processor
	Simple english like statements -> OS System routines -> Commands -> ZEROs and ONEs

Java is a Object Oriented Programing Language (OOP)

	Object Oriented Programing Language has 4 Principles
	1. Encapsulation
	2. Inheritance
	3. Abstraction
	4. Polymorphism
	
What we can develop using Java?
	Standalone Applications, Web Applications, Enterprise Applications

Which company developed Java?
	Sun MicroSystem -> Oracle

Define Java?
	Java is a High level, Object oriented programming language and used to develop Standalone, Web and Enterprise Applications. It was developed by Sun MicroSystem and Now Owned by Oracle.

Explain Object oriented Programing Language Principles?

Object Oriented Programing Language has 4 Principles
	1. Encapsulation
	2. Inheritance
	3. Abstraction
	4. Polymorphism

1. Encapsulation - is the process of binding Data and Functionality together in Single Entity.
	By using class and object we achieve Encapsulation.
	
	Class -> Object 1, Object 2

	Logical - 
	Class { 
		data - data variable
		functionality: data + 2 - method
	}

	Physical - 
	Object 1 {
		data = 3
		functionality: 3+2=5
	}
	
	Object 2 {
		functionality: 0+2=2 <Note: data is 0 by default if we don't assign value>
	}

CODE EXAMPLE:
public class NumberProcessor {

	// Special method called Constructor
	public NumberProcessor(){
		// initialize the data members
		data = 44;
	}
		
	public int data;
	
	public void addAndPrint(){
		
		int addedValue = data + 2;
		
		System.out.println(addedValue);
	}
	
	public static void main(String[] array){
		
		NumberProcessor object1 = new NumberProcessor();
	
		object1.data = 3;
				
		object1.addAndPrint();
		
		NumberProcessor object2 = new NumberProcessor();
		
		object2.addAndPrint();
		
		NumberProcessor object3 = new NumberProcessor();
		
		object3.data = 78;
		
		object3.addAndPrint();	
	}
}

01-JUNE-2023
------------

Define Class?
Class is a logical structure which has set of Data members and Functionality.
Class is a logical structure which has set of Data members, Methods and Constructors.

Define Variable?
Variable is a name/reference to the memory location and holds the link to that memory location.

Define Method?
Method is a set of instructions to serve the Functionality.

Define Constructor?
Constructor is special method used initialize the data members.
Constructor will have the same name Class name.

Define Object?
Object is physical entity of the Class.
When we create Object, memory will be allocated to Data members of the class and Constructor will called and initialize the data members

02-JUNE-2023
------------

2. Inheritance
It is a process of acquiring the properties of Parent/Super class into Child/Sub class
It is a process of acquiring the Data and Functionality of Parent/Super class into Child/Sub class
It is a process of extending the properties of Parent class into Child class

Inheritance is called "IS A" Relationship

Parent/Super/Base
Child/Sub/Derived

we need at least two classes:
Parent
Child

class Parent {

	public Parent(){
		vehicle = "Car";
	}
	
	String vehicle = "Car";
	
	public void drive(){
		System.out.println("Parent: "+vehicle);
	}
}

class Child extends Parent{
		
	public static void main(String[] array){
	
		Child object = new Child();
		
		object.drive();
	}
}

1. Single
2. Multi-Level
3. Hierarchical
4. Multiple
5. Hybrid

1. Single Inheritance
It is the process of one Child extending the properties of One Parent.

Parent -> Child

class Anil {
	
	String car;
	
	public Anil(){
		car = "Kia";
	
		System.out.println("Anil Constructor Called");
	}
	
	public void driveCar(){
		System.out.println("Driving car:"+car);
	}
}

class Bharat extends Anil {
	
	String bike;
		
	public void driveBike(){
		System.out.println("Driving bike:"+bike);
	}
}

public class Test {
	
	public static void main(String[] arr){
		
		Anil a = new Bharat();
		
		a.driveCar();
	}
}

2. Multi-Level
It is the Process of having Single Parent-Child Chain Relationship

Parent -> Child -> Child -> Child -> ...

class Anil {
	
	public Anil(){
		car = "Kia";
	
		System.out.println("Anil Constructor Called");
	}
	
	String car;
		
	public void driveCar(){
		System.out.println("Driving car:"+car);
	}
}

class Bharat extends Anil {
	
	String bike;
	
	public void driveBike(){
		System.out.println("Driving bike:"+bike);
	}
}

class Chandu extends Bharat {

	public Chandu() {
		super();
		phone = "Apple";
	}

	String phone;
	
	public void usePhone(){
		System.out.println("Use phone:" +phone);
	}
}

public class MLTest{
	
	public static void main(String[] array){
		
		Chandu c = new Chandu();
		
		c.phone = "MI";
		
		c.usePhone();
		
		c.driveBike();
		
		c.driveCar();
	}
}

Anil Constructor Called
Use phone:MI
Driving bike:null
Driving car:Kia

05-JUNE-2023
------------
3. Hierarchical Inheritance

It is the process of Single Parent and Multiple Child Chain Relationship.

Parent -> Child-1 and Child-2

Child-1 -> Child-11 and Child-12

class Anil {
	
	public Anil(){
		car = "Kia";
	
		System.out.println("Anil Constructor Called");
	}
	
	String car;
	
	public void driveCar(){
		System.out.println("Driving car:"+car);
	}
}

class Bharat extends Anil {
	
	String bike;
	
	public void driveBike(){
		System.out.println("Driving bike:"+bike);
	}
}

class John extends Anil {
		
	String computer = "DELL";

	public void workOnComputer(){
		System.out.println("Working on Computer: "+ computer);
	}
}

public class HirarchicalInheritance {
	
	public static void main(String[] a) {
		
		Bharat b = new Bharat();
		
		b.driveCar();
		
		b.bike = "Pulser";
		
		b.driveBike();
		
		John j = new John();
		
		j.car = "Maruthi";
		
		j.driveCar();
		
		j.workOnComputer();
		
		b.driveCar();
	}
}

Output:
Anil Constructor Called
Driving car:Kia
Driving bike:Pulser
Anil Constructor Called
Driving car:Maruthi
Working on Computer: DELL
Driving car:Kia

Interface:
----------
Interface is a contract to the class.

Abstract method is a method which does not have Functionality.

Interface is a contract to the class and it has set of Constants and Abstract methods.
Interface does not have Data members and Constructors.

Interface can be extends from another Interface.

Logical structure -> Real entity
Class -> Object

interface Car {
	
	int CONSTANT=1;

	void driveCar();
	void driveCarWith6Gears();
}

abstract class KiaCar implements Car {

	public void driveCar(){
		System.out.println("Driving Kia Car");
	}
}

class KiaXCar extends KiaCar {

	public void driveCarWith6Gears(){
		System.out.println("Driving Kia Car with 60KMPH");
	}
}

class KiaYCar extends KiaCar {

	public void driveCarWith6Gears(){
		System.out.println("Driving Kia Car with 100KMPH");
	}
}

public class InterfaceExample {

	public static void main(String[] a){
		
		Car c = new KiaXCar();
		
		c.driveCar();
		
		c.driveCarWith6Gears();
		
		Car cy = new KiaYCar();
		
		cy.driveCar();
		
		cy.driveCarWith6Gears();
	}
}

Driving Kia Car
Driving Kia Car with 60KMPH
Driving Kia Car
Driving Kia Car with 100KMPH

interface Horn {
	void soundHorn();
}

interface Car extends Horn {
	public abstract void driveCar();	
}

06-JUNE-2023
------------
4. Multiple Inheritance

It is the process of Single Child Having Multiple Parents

Child -> Parent 1 and Parent 2

By default Java does not support Multiple Inheritance with Classes.

We can achieve Multiple Inheritance in Java using Interfaces

07-JUNE-2023
------------
interface Car {
	public abstract void driveCar();	
}
class Horn {
	void soundHorn(){
		System.out.println("Horn sound");
	}
}
class KiaCar extends Horn implements Car {
	public void driveCar(){
		System.out.println("Driving Kia Car");
	}
}
public class MultipleInheritance {
	public static void main(String[] arr){
		KiaCar c = new KiaCar();
		
		c.soundHorn();
		c.driveCar();					
	}	
}

5. Hybrid Inheritance
---------------------
Hybrid Inheritance is a combination of Hierarchical Inheritance and Multiple Inheritance

Parent 1 -> Child 1, Child 2 --> Hierarchical Inheritance
Child 1, Child 2 -> Child 3 --> Multiple Inheritance

Anil -> Bharat , Chandu --> Hierarchical Inheritance
Bharat, Chandu -> Dharma --> Multiple Inheritance

Results in Hybrid Inheritance

interface Car {
	public abstract void driveCar();
}
interface Horn extends Car {
	void soundHorn();
}
class KiaCar implements Car {
	public void driveCar(){
		System.out.println("driveCar called");
	}
}
class KiaXCar extends KiaCar implements Horn {
	public void soundHorn(){
		System.out.println("soundHorn called");
	}
}
public class HybridInheritance {
	public static void main(String[] arr){
		KiaXCar c = new KiaXCar();
		c.soundHorn();
		c.driveCar();			
	}	
}

08-JUNE-2023
------------
// NumberProcessor is class name
public class NumberProcessor {

	// Special method called Constructor
	// NumberProcessor() is a Constructor
	public NumberProcessor(){
		// initialize the data members
		data = 44;
	}
	// data is instance variable	
	public int data;
	
	// addAndPrint() is a instance method definition
	// addAndPrint() is concrete method
	public void addAndPrint(){
		// addedValue is local variable
		int addedValue = data + 2;
		
		System.out.println(addedValue);
	}
	
	public static void main(String[] array){
		
		// new NumberProcessor() is a object or instance
		// object1 is a reference variable of type NumberProcessor and holding the object/instance // of NumberProcessor class
		NumberProcessor object1 = new NumberProcessor();
	
		// object1.data is assigning data instance variable using object1 reference variable
		object1.data = 3;
		
		// object1.addAndPrint(); is calling instance method using object1 reference variable
		object1.addAndPrint();
	}
}

3. Abstraction
--------------
Abstraction is process hiding unnecessary details and represent required details.

To achieve Abstraction, we have to use Interfaces and/or Abstract classes with Inheritance.

Interface: 
Interface is a contract to the class and it has set of Constants and Abstract Methods.
Abstract Method: Method with No definition. It has only Declaration
Constant: Constant is Variable which contains Constant Value which can not modify

Interface with no Methods is called Marker interface.
Marker interface: is a special interface used to give Special instructions to Java while creating the Object of child class of that Marker interface.

Abstract Class: is a class which contains data members and set of concrete methods and/or abstract methods.

For abstract class we can not create object.

abstract class Car {
	
	int data;
	
	void driveCar(){
		System.out.println("driving car");
	}
	
	abstract void soundHorn();
}

class kiaCar extends Car {
	
	void soundHorn(){
		System.out.println("Sound horn");
	}	
}

09-JUNE-2023
------------
interface Car {
	void driveCar();
	void soundHorn();
}
class KiaXCar implements Car {
	public void driveCar(){
		System.out.println("driving x car");
	}
	public void soundHorn(){
		System.out.println("sound x car horn");
	}
}
class KiaYCar implements Car {
	public void driveCar(){
		System.out.println("driving y car");
	}
	public void soundHorn(){
		usePopSoundDriverAndMakeSound();
	}
	public void usePopSoundDriverAndMakeSound(){
		System.out.println("sound y car horn");
	}
}
650- Car xCar = new KiaXCar();
651- xCar.driveCar();
652- xCar.soundHorn();

654- Car yCar = new KiaYCar();
655- yCar.driveCar();
656- yCar.soundHorn();

651-driving x car
652-sound x car horn
655-driving y car
656-sound y car horn

12-JUNE-2023
------------
4. Polymorphism

Polymorphism refers to many forms.
As per Polymorphism, We can perform one action in many ways.

to achieve Polymorphism, we have to use Interfaces and/or Abstract classes with Inheritance.

We have 2 types of Polymorphism,
-> Method overloading
-> Method overriding

Method: set of instructions given to perform specific functionality.

Method Syntax:
accessSpecifier returnType methodName(parameters) {
	// instructions
}

public void driveCar(int data){
	System.out.println("Driving car: "+data);
}

Every method has a Signature.

As part of method, we have Signature and Instructions

Signature refers to methodName, parameters of a method

methodName(parameters) {
	// instructions
}

Signature {
	// instructions
}

With respect to Signature->
	functionality does not matter,
	parameters names does not matter,
	number of parameter matters,
	parameter data type matters and
	parameter order matters

15-JUNE-2023
------------
-> Method overloading
Multiple methods with same name with different Signature is called Method overloading.
It is called Compile-time Polymorphism.
It is called Static Polymorphism.

public class NumberProcessor {
	public void addAndPrint(int data){
		int addedValue = data + 2;

		System.out.println(addedValue);
	}
	public void addAndPrint(double data){
		double addedValue = data + 2;

		System.out.println(addedValue);
	}
	public void addAndPrint(int x, int y){
		int addedValue = x + y + 78;

		System.out.println(addedValue);
	}
	public void addAndPrint(int data, double y){
		double addedValue = data + y + 78;

		System.out.println(addedValue);
	}
	public static void main(String[] array){
		NumberProcessor ref = new NumberProcessor();
		ref.addAndPrint(44);
		ref.addAndPrint(44, 66);
		ref.addAndPrint(44, 66.8);
	}
}

O/P:
46
46.7
188
188.8

16-JUNE-2023
------------
-> Method overriding

Method overriding is process having same method in Child class and Parent interface/class
- Parent and child class relationship(Inheritance) is mandatory
Same method: accessSpecifier returnType Signature
It is Runtime-Polymorphism - Method called at runtime based on Object created
It is called Dynamic Polymorphism - Method called based on objected
Dynamic method dispatch - Method called based on objected

interface Car {
	public abstract void driveCar();
	public abstract void soundHorn();
}
class KiaCar implements Car {
	public void driveCar() {
		System.out.println("Driving KiaCar");
	}
	public void soundHorn(){
		System.out.println("Making sound from KiaCar");
	}
}
class KiaXCar extends KiaCar {
	public void soundHorn(){
		System.out.println("Making sound from KiaXCar");
	}
}
public class MethodOverRidingSecondExample {
	public static void main(String[] arr){
		Car car = new KiaCar();
		
		car.driveCar();
		
		car.soundHorn();
		
		Car carX = new KiaXCar();
		
		carX.driveCar();
		
		carX.soundHorn();
	}
}

super keyword:
--------------
- super() is used in child class constructor to call Parent class constructor to initialize data members of parent class
- super(parameters) - is used in child class constructor to call parameterized constructor of the parent class
- super keyword used to access instance data members of parent class in child class
- super keyword used to access instance methods of parent class in child class

class Parent {
	int number1 = 3;
	public void print(){
		System.out.println("Print from Parent: "+ number1);
	}
}
class Child extends Parent {
	public Child(){
		super();
		number1 = 8;
	}
	int number1 = 0;
	public void print(){
		super.print();
		System.out.println("Print from Child with parent Value: "+ super.number1);
		System.out.println("Print from Child: "+ (number1+2));
	}
}
public class NumberProcessor{
	public static void main(String[] array){
		Child ref = new Child();
		ref.print();
	}
}

19-JUNE-2023
------------
Constructor Overloading:
It is the process of Multiple Constructors with different Signature
Example:
Parent()
Parent(int a)

class Parent {
	int number1;
	int number2;
	double number3;
	
	public Parent(){
	}
	public Parent(int a){
		number1 = a;
	}
	public Parent(int a, int b){
		number1 = a;
		number2 = b;
	}
	public Parent(int a, double b){
		number1 = a;
		number3 = b;
	}
	public Parent(int a, int b, double c){
		number1 = a;
		number2 = b;
		number3 = c;
	}
	public void print(){
		System.out.println("Print number1 from Parent: "+ number1);
		System.out.println("Print number2 from Parent: "+ number2);
		System.out.println("Print number3 from Parent: "+ number3);
	}
}
class Child extends Parent {
	int number1;
	
	public Child(){
		super();
		number1 = 99;
	}
	public Child(int a){
		super();
		number1 = 77;
	}
	public Child(int a, double c){
		super(a, c);
		number1 = 77;
	}	
	public void print(){
		super.print();
		System.out.println("Print from Child with parent Value: "+ super.number1);
		System.out.println("Print from Child: "+ (number1+2));
	}
}
public class NumberProcessor{
	public static void main(String[] array){
		Child ref = new Child();
		ref.print();
		
		Child ref1 = new Child(565);
		ref1.print();
		
		Child ref2 = new Child(12, 56.45);
		ref2.print();
	}
}

20-JUNE-2023
------------
this keyword:

this() - used to call zero parameterized constructor of the same class from another constructor
this(parameters) - used to call parameterized constructor of the same class from another constructor
this keyword used to access the instance variables of the same class
this keyword used to access the instance methods of same class

Both super and this can not be used at same in constructor.
Both super and this used to deal with only constructors, instance variables and instance methods

class Parent {
	int number1;
	int number2;
	
	public Parent(){
		this(1, 2);
		System.out.println("From zero parameterized constructor");
	}
	public Parent(int a){
		this();
		number1 = a;
	}
	public Parent(int a, int b){
		number1 = a;
		number2 = b;
	}
	public void print(){		
		System.out.println("Print number1 from Parent: "+ number1);
		System.out.println("Print number2 from Parent: "+ number2);
	}
}
class Child extends Parent {
	int number1;
	
	public Child(){
		super(33);
		number1 = 77;
	}
	public Child(int a){
		number1 = a;
	}
	public Child(int a, int c){
		this(a);
		number1 = a;
	}	
	public void print(){
		super.print();
		System.out.println("Print from Child with parent Value: "+ super.number1);
		System.out.println("Print from Child: "+ (number1+2));
	}
}
public class NumberProcessor2{
	public static void main(String[] array){
		Child ref = new Child(565, 4);
		ref.print();
		
	}
}

class Parent {
	int number1;
	int number2;
	
	public Parent(){
		this(1, 2);
		System.out.println("From zero parameterized constructor");
	}
	public Parent(int a){
		this();
		number1 = a;
	}
	public Parent(int a, int b){
		number1 = a;
		number2 = b;
	}
	public void print(){		
		System.out.println("Print number1 from Parent: "+ number1);
		System.out.println("Print number2 from Parent: "+ number2);
	}
}
class Child extends Parent {
	int number1;
	
	public Child(){
		super(33);
		number1 = 77;
	}
	public Child(int a){
		number1 = a;
	}
	public Child(int number1, int c){
		this(number1);
		this.number1 = number1;
	}	
	public void print(){
		super.print();
		System.out.println("Print from Child with parent Value: "+ super.number1);
		System.out.println("Print from Child: "+ (number1+2));
	}
	public void printNumbers(){
		int number1 = 58;
		System.out.println("Print Local variable: "+ (number1+2));
		System.out.println("Print Instance variable: "+ (this.number1+2));
		System.out.println("Print Instance variable from parent: "+ (super.number1+2));
	}
	public void useMethods(){
		this.print();
		super.print();
	}
}
public class ThisExample{
	public static void main(String[] array){
		Child ref = new Child(565, 4);
		ref.print();
		
	}
}

Object class
------------
Object is a class.
Object is a Predefined class in Java.
Every class in Java is a child of Object class directly or indirectly.
All classes are child classes of Object class directly or indirectly.

-- If we don't extend our class from any other class,
then compiler will give Object class as a default parent.

Object class has 9 methods as below

public class java.lang.Object {
  public java.lang.Object(); - Constructor
  public final native java.lang.Class<?> getClass();
  public native int hashCode();
  public boolean equals(java.lang.Object);
  protected native java.lang.Object clone();
  public java.lang.String toString();
  public final native void notify();
  public final native void notifyAll();
  public final void wait();
  public final native void wait(long);
  public final void wait(long, int);
  protected void finalize();
}

public class Calculator extends Object {
	public void add(){
		System.out.println(2+5);
		
		int hashCode = super.hashCode();
		
		System.out.println("Hashcode: "+hashCode);
	}
	public static void main(String[] arr){
		Calculator c = new Calculator();
		c.add();
	}
}

21-JUNE-2023
------------
Compilation process:
--------------------
In Java, we use "javac" command to compile the code.
Syntax: javac ClassName.java
Ex: javac Calculator.java

What happens when we compile code?
1. Check for Syntax and Semantic errors
	i. Java provided Keywords spelled correctly or not
	ii. Symbols like braces, dots, quotes, semi colon, etc
	iii. Variables used are present in class
	iv. Methods used are present in class
	v. Method declaration correct or not
	vi. Variable declaration correct or not
	
2. If class does not have any direct Parent it will add Object class as Parent
3. Default constructor will be added if there are no constructors defined
4. super() will be added as a first statement in Child Class Constructor if it is not added
5. When we implements interface, it will check, child class provided definition to all the interface abstract methods or not
6. If we create a object of a class and place it in other interface or class reference variable, then compiler check the relationship between the involved interface and classes
7. When we use a data member using reference variable, then compiler will check the variable is present in that class or its parent class, if its not there in that class or parent class then compiler will give error
8. When we call a method using reference variable, then compiler will check the method is present in that class or its parent class, if its not there in that class or parent class then compiler will give error
9. Once all checks complete and no errors found, compilation will be completed successfully

What happens when Compile completed successfully?
1. for every class one ".class" file will be created
   Name of ".class" file will be ClassName.class
   Ex: Calculator.class
2. If we have multiple classes declared in single .java file then after compilation,
   separate .class file will be created based on the number of classes present that .java file
3. In generated ".class" file, byte code will be placed

Who will use ".class" file?
1. Java will use the ".class" file
2. At the time of running code, Java uses ".class" file

22-JUNE-2023 / 23-JUNE-2023
---------------------------
Execution/Running process:
--------------------------
In Java, we use "java" command to run the code.
Syntax: java ClassName
Ex: java Calculator

What happens when we run the code?
JVM look for ".class" file with ClassName we provided
If JVM finds, ".class" file then Java look for main() method in Provided class

If JVM finds, main() method then it will start executing method by calling it
	Syntax of main() method Java look for:
	public static void main(String[] paramName){}

We should not give .class extension while running the code

JVM - Java Virtual Machine
--------------------------
JVM is a Execution Engine
JVM will run the Java Code

When we use 'java' command to run the code JVM gets started.
Once started memory will be allocated to JVM
If we create objects, memory will be allocated to objects in JVM

JVM has below components
------------------------
1. Class Loader
2. Runtime Data Area
3. Execution Engine
4. Java Native Interface
5. Garbage Collector

1. Class Loader
---------------
Class loader is used to Load the Class into JVM Memory(Method Area).
If the loaded class uses any other class then Class loader will load that class also.
Once class is loaded, it will identify Data members and Methods and memory will allocated.
Class loader only stores the Meta data of the class into memory.
Ex: class name, variable type and method names with definition, etc.
Once class is loaded in to JVM memory, If the class contains static variables, then memory will be allocated to static variables and initialized with default values or user given values

2. Runtime Data Area (JVM Memory)
	JVM Memory:
	-----------
	Method Area
	Heap
	Java Stack
	PC Register
	Native Method Stack

	Method Area Memory:
	Method area is used to allocate memory to meta data of the class
	Method area is used to allocate memory to the Local variables

	Heap Memory:
	When we create object, memory will be allocated inside Heap memory
	Heap Memory is used to allocate memory to Instance variables of the class and its Parent class

	Java Stack:
	Java Stack is used to hold the Currently executing User defined, predefined methods.
	If we call a method, method will be placed in Java Stack, from that method if we call any other method that also placed Java Stack
	Only User defined, predefined methods will be placed in Java Stack.

	PC Register:
	PC Register points to Currently executing instruction.

	Native Method Stack:
	Native Method is method coming from Other programming languages.
	Native Method Stack is used to hold the Currently executing native method.

3. Execution Engine
	Two components:
	---------------
	Interpreter
	JIT Compiler (Just-In-Time)

	Interpreter: 
	It is used to execute the instructions line by line
	It converts Java instructions into Machine level instructions/Machine Language
	It passes that Machine level instructions to Processor/CPU

	JIT Compiler: 
	It used to help Interpreter with Java Instructions which are already converted into Machine level instructions,
	So that Interpreter do not need to convert Java Instructions into Machine level instructions again and again.
	
	So with the help of JIT Compiler, Interpreter will execute instructions fastly by passing it to Processor.

4. Java Native Interface (JNI)
   JVM uses JNI to call Native methods
   
5. Garbage Collector
   It used to clean unused Objects in JVM Memory.
   When JVM shutdown, Garbage Collector cleanup all objects memory.
   In case if execution still progress but there are some unused objects are there which are Eligible for Garbage Collector to cleanup, in that case it is up to Garbage Collector, when to clean up those unused objects.

-----------------------
when we run java ThisExample
JVM starts and memory will be allocated to JVM

Class loader looks ThisExample.class file
once found, class loader loads ThisExample.class file in to JVM Memory(Method Area)
Memory will be allocated to Meta data of ThisExample class

JVM look for main method in ThisExample class
Once it found start executing

method will be placed in stack
PC register points to first instruction
Interpreter converts that instruction to machine level instruction
Interpreter passes that machine level instruction to Processor
----------------------------

26-JUNE-2023
------------
Object creation process:
------------------------
1. Object creation starts
2. Memory will be allocated to all instance data members
3. Initialize all the instance data members with default values
4. Constructor gets called to initialize instance data members with specific values
5. Object creation completed

static:
-------
static is key word in Java.
static is used to create class level data members and class level methods
static is used to create class level variables and class level methods

class level variable: it a is variable and will be declared with static key word and we call the variable as static variable
syntax:  static datatype variableName;
example: static int a; //- static variable a
Memory will be allocated to static variables at the time of class loading.
static variables gets initialized at the time of class loading.
We can access static variables with class name itself, no need to creating object.

27-JUNE-2023
------------
class level method: it is a method and will be declared with static key word and we call the method as static method.
syntax: static returnType signature(){}
example: static void main(){}

We can access static methods with class name itself, no need to creating object.

We are creating main method as static so while executing JVM will call main method directly by using provided class name with out creating object.

public class Student {
	int rollNumber;
	String studentName;
	int marks;	
	static String collegeName;
	
	public Student(){}
	public Student(int rollNumber, String studentName, int marks){
		this.rollNumber = rollNumber;
		this.studentName = studentName;
		this.marks = marks;
	}
	public void print() {
		System.out.printf("rollNumber: %d, studentName: %s, marks: %d, collegeName: %s\n", rollNumber, studentName, marks, collegeName);
	}
	public static void printCollegeName(){
		System.out.printf("collegeName: %s\n", collegeName);
	}
	public static void main(String[] arr){		
		Student.collegeName = "CBIT";
		
		Student.printCollegeName();

		Student s1 = new Student();
		s1.rollNumber = 2;
		s1.studentName = "Bharat";
		s1.marks = 678;	
		
		s1.print();		

		Student s2 = new Student(3, "Chandu", 555);
		s2.print();
	}
}

Instance reference variable:
----------------------------
If we create a reference variable of a class in other class as instance variable then it is called Instance reference variable.
When we create Instance reference variable in a class then that relationship is called as "HAS A" relationship.

class Address {
	String houseNumber;
	String city;
	String state;
	String country;
	
	Address(String houseNumber, String city, String state, 	String country){
		this.houseNumber=houseNumber;
		this.city=city;
		this.state=state;
		this.country=country;		
	}
	public void printAddress(){
		System.out.printf("%S, %S, %S, %S\n", houseNumber,city,state,country);
	}
}
public class Person {
	String name;
	int age;
	String gender;
	Address address;
	
	Person(String name, int age, String gender, Address address){
		this.name=name;
		this.age=age;
		this.gender=gender;	
		this.address = address;
	}	
	public void print() {
		System.out.printf("%S, %d, %S, %S\n", name,age,gender,address.country);
		address.printAddress();
	}	
	public static void main(String[] arr){	
		
		Address addressReference = new Address("9-889", "Hydrabad", "Telangana", "India");
	
		Person p = new Person("Anil", 33, "Male", addressReference);
		
		p.print();		
	}
}
