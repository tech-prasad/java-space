Java:
-----

30-MAY-2023
-----------

Processor is Hardware which understands only Binary numbers (0,1)

User instruction -> Calculator -> OS -> Processor
User instruction -> calculator -> OS System Routines -> Commands -> ZEROs and ONEs

Processor - 
Low level or Machine language - ZEROs and ONEs
Middle level or Assembly language - Commands
	Commands: add 2 2 , sub 2 2

OS -
System routines

Binary:
0 1 -> 0 1 2 3 4

0 - 0 0
1 - 0 1
2 - 1 0
3 - 1 1
4 - 1 0 0
8 - 1 0 0 0

2 power 0
2 power 1
2 power 2

Octal:
8 power 0
8 power 1
8 power 2

Decimal:
10 power 0
10 power 1
10 power 2

HexaDecimal:
16 power 0
16 power 1
16 power 2

0 15
0 .. 9 a b .. f


31-MAY-2023
-----------

Programing languages:
Java
C
C++
C#
SQL
Java-script

Java Programing Language:

What is Java?

Java is a High Level Programing Language

	High Level: Simple english like statements [object1.addAndPrint()]

	Simple english like statements -> OS -> Processor
	Simple english like statements -> OS System routines -> Commands -> ZEROs and ONEs

Java is a Object Oriented Programing Language (OOP)

	Object Oriented Programing Language has 4 Principles
	1. Encapsulation
	2. Inheritance
	3. Abstraction
	4. Polymorphism
	
What we can develop using Java?
	Standalone Applications, Web Applications, Enterprise Applications

Which company developed Java?
	Sun MicroSystem -> Oracle

Define Java?
	Java is a High level, Object oriented programming language and used to develop Standalone, Web and Enterprise Applications. It was developed by Sun MicroSystem and Now Owned by Oracle.

Explain Object oriented Programing Language Principles?

Object Oriented Programing Language has 4 Principles
	1. Encapsulation
	2. Inheritance
	3. Abstraction
	4. Polymorphism

1. Encapsulation - is the process of binding Data and Functionality together in Single Entity.
	By using class and object we achieve Encapsulation.
	
	Class -> Object 1, Object 2

	Logical - 
	Class { 
		data - data variable
		functionality: data + 2 - method
	}

	Physical - 
	Object 1 {
		data = 3
		functionality: 3+2=5
	}
	
	Object 2 {
		functionality: 0+2=2 <Note: data is 0 by default if we don't assign value>
	}

CODE EXAMPLE:
public class NumberProcessor {

	// Special method called Constructor
	public NumberProcessor(){
		// initialize the data members
		data = 44;
	}
		
	public int data;
	
	public void addAndPrint(){
		
		int addedValue = data + 2;
		
		System.out.println(addedValue);
	}
	
	public static void main(String[] array){
		
		NumberProcessor object1 = new NumberProcessor();
	
		object1.data = 3;
				
		object1.addAndPrint();
		
		NumberProcessor object2 = new NumberProcessor();
		
		object2.addAndPrint();
		
		NumberProcessor object3 = new NumberProcessor();
		
		object3.data = 78;
		
		object3.addAndPrint();	
	}
}

01-JUNE-2023
------------

Define Class?
Class is a logical structure which has set of Data members and Functionality.
Class is a logical structure which has set of Data members, Methods and Constructors.

Define Variable?
Variable is a name/reference to the memory location and holds the link to that memory location.

Define Method?
Method is a set of instructions to serve the Functionality.

Define Constructor?
Constructor is special method used initialize the data members.
Constructor will have the same name Class name.

Define Object?
Object is physical entity of the Class.
When we create Object, memory will be allocated to Data members of the class and Constructor will called and initialize the data members

02-JUNE-2023
------------

2. Inheritance
It is a process of acquiring the properties of Parent/Super class into Child/Sub class
It is a process of acquiring the Data and Functionality of Parent/Super class into Child/Sub class
It is a process of extending the properties of Parent class into Child class

Inheritance is called "IS A" Relationship

Parent/Super/Base
Child/Sub/Derived

we need at least two classes:
Parent
Child

class Parent {

	public Parent(){
		vehicle = "Car";
	}
	
	String vehicle = "Car";
	
	public void drive(){
		System.out.println("Parent: "+vehicle);
	}
}

class Child extends Parent{
		
	public static void main(String[] array){
	
		Child object = new Child();
		
		object.drive();
	}
}

1. Single
2. Multi-Level
3. Hierarchical
4. Multiple
5. Hybrid

1. Single Inheritance
It is the process of one Child extending the properties of One Parent.

Parent -> Child

class Anil {
	
	String car;
	
	public Anil(){
		car = "Kia";
	
		System.out.println("Anil Constructor Called");
	}
	
	public void driveCar(){
		System.out.println("Driving car:"+car);
	}
}

class Bharat extends Anil {
	
	String bike;
		
	public void driveBike(){
		System.out.println("Driving bike:"+bike);
	}
}

public class Test {
	
	public static void main(String[] arr){
		
		Anil a = new Bharat();
		
		a.driveCar();
	}
}


2. Multi-Level
It is the Process of having Single Parent-Child Chain Relationship

Parent -> Child -> Child -> Child -> ...

class Anil {
	
	public Anil(){
		car = "Kia";
	
		System.out.println("Anil Constructor Called");
	}
	
	String car;
		
	public void driveCar(){
		System.out.println("Driving car:"+car);
	}
}

class Bharat extends Anil {
	
	String bike;
	
	public void driveBike(){
		System.out.println("Driving bike:"+bike);
	}
}

class Chandu extends Bharat {

	public Chandu() {
		super();
		phone = "Apple";
	}

	String phone;
	
	public void usePhone(){
		System.out.println("Use phone:" +phone);
	}
}

public class MLTest{
	
	public static void main(String[] array){
		
		Chandu c = new Chandu();
		
		c.phone = "MI";
		
		c.usePhone();
		
		c.driveBike();
		
		c.driveCar();
	}
}

Anil Constructor Called
Use phone:MI
Driving bike:null
Driving car:Kia

05-JUNE-2023
------------
3. Hierarchical Inheritance

It is the process of Single Parent and Multiple Child Chain Relationship.

Parent -> Child-1 and Child-2

Child-1 -> Child-11 and Child-12

class Anil {
	
	public Anil(){
		car = "Kia";
	
		System.out.println("Anil Constructor Called");
	}
	
	String car;
	
	public void driveCar(){
		System.out.println("Driving car:"+car);
	}
}

class Bharat extends Anil {
	
	String bike;
	
	public void driveBike(){
		System.out.println("Driving bike:"+bike);
	}
}

class John extends Anil {
		
	String computer = "DELL";

	public void workOnComputer(){
		System.out.println("Working on Computer: "+ computer);
	}
}

public class HirarchicalInheritance {
	
	public static void main(String[] a) {
		
		Bharat b = new Bharat();
		
		b.driveCar();
		
		b.bike = "Pulser";
		
		b.driveBike();
		
		John j = new John();
		
		j.car = "Maruthi";
		
		j.driveCar();
		
		j.workOnComputer();
		
		b.driveCar();
	}
}

Output:
Anil Constructor Called
Driving car:Kia
Driving bike:Pulser
Anil Constructor Called
Driving car:Maruthi
Working on Computer: DELL
Driving car:Kia

Interface:
----------
Interface is a contract to the class.

Abstract method is a method which does not have Functionality.

Interface is a contract to the class and it has set of Constants and Abstract methods.
Interface does not have Data members and Constructors.

Interface can be extends from another Interface.

Logical structure -> Real entity
Class -> Object

interface Car {
	
	int CONSTANT=1;

	void driveCar();
	void driveCarWith6Gears();
}

abstract class KiaCar implements Car {

	public void driveCar(){
		System.out.println("Driving Kia Car");
	}
}

class KiaXCar extends KiaCar {

	public void driveCarWith6Gears(){
		System.out.println("Driving Kia Car with 60KMPH");
	}
}

class KiaYCar extends KiaCar {

	public void driveCarWith6Gears(){
		System.out.println("Driving Kia Car with 100KMPH");
	}
}

public class InterfaceExample {

	public static void main(String[] a){
		
		Car c = new KiaXCar();
		
		c.driveCar();
		
		c.driveCarWith6Gears();
		
		Car cy = new KiaYCar();
		
		cy.driveCar();
		
		cy.driveCarWith6Gears();
	}
}

Driving Kia Car
Driving Kia Car with 60KMPH
Driving Kia Car
Driving Kia Car with 100KMPH

interface Horn {
	void soundHorn();
}

interface Car extends Horn {
	public abstract void driveCar();	
}

06-JUNE-2023
------------
4. Multiple Inheritance

It is the process of Single Child Having Multiple Parents

Child -> Parent 1 and Parent 2

By default Java does not support Multiple Inheritance with Classes.

We can achieve Multiple Inheritance in Java using Interfaces

07-JUNE-2023
------------
interface Car {
	public abstract void driveCar();	
}
class Horn {
	void soundHorn(){
		System.out.println("Horn sound");
	}
}
class KiaCar extends Horn implements Car {
	public void driveCar(){
		System.out.println("Driving Kia Car");
	}
}
public class MultipleInheritance {
	public static void main(String[] arr){
		KiaCar c = new KiaCar();
		
		c.soundHorn();
		c.driveCar();					
	}	
}

5. Hybrid Inheritance
---------------------
Hybrid Inheritance is a combination of Hierarchical Inheritance and Multiple Inheritance

Parent 1 -> Child 1, Child 2 --> Hierarchical Inheritance
Child 1, Child 2 -> Child 3 --> Multiple Inheritance

Anil -> Bharat , Chandu --> Hierarchical Inheritance
Bharat, Chandu -> Dharma --> Multiple Inheritance

Results in Hybrid Inheritance

interface Car {
	public abstract void driveCar();
}
interface Horn extends Car {
	void soundHorn();
}
class KiaCar implements Car {
	public void driveCar(){
		System.out.println("driveCar called");
	}
}
class KiaXCar extends KiaCar implements Horn {
	public void soundHorn(){
		System.out.println("soundHorn called");
	}
}
public class HybridInheritance {
	public static void main(String[] arr){
		KiaXCar c = new KiaXCar();
		c.soundHorn();
		c.driveCar();			
	}	
}

08-JUNE-2023
------------
// NumberProcessor is class name
public class NumberProcessor {

	// Special method called Constructor
	// NumberProcessor() is a Constructor
	public NumberProcessor(){
		// initialize the data members
		data = 44;
	}
	// data is instance variable	
	public int data;
	
	// addAndPrint() is a instance method definition
	// addAndPrint() is concrete method
	public void addAndPrint(){
		// addedValue is local variable
		int addedValue = data + 2;
		
		System.out.println(addedValue);
	}
	
	public static void main(String[] array){
		
		// new NumberProcessor() is a object or instance
		// object1 is a reference variable of type NumberProcessor and holding the object/instance // of NumberProcessor class
		NumberProcessor object1 = new NumberProcessor();
	
		// object1.data is assigning data instance variable using object1 reference variable
		object1.data = 3;
		
		// object1.addAndPrint(); is calling instance method using object1 reference variable
		object1.addAndPrint();
	}
}

3. Abstraction
--------------
Abstraction is process hiding unnecessary details and represent required details.

To achieve Abstraction, we have to use Interfaces and/or Abstract classes with Inheritance.

Interface: 
Interface is a contract to the class and it has set of Constants and Abstract Methods.
Abstract Method: Method with No definition. It has only Declaration
Constant: Constant is Variable which contains Constant Value which can not modify

Interface with no Methods is called Marker interface.
Marker interface: is a special interface used to give Special instructions to Java while creating the Object of child class of that Marker interface.

Abstract Class: is a class which contains data members and set of concrete methods and/or abstract methods.

For abstract class we can not create object.

abstract class Car {
	
	int data;
	
	void driveCar(){
		System.out.println("driving car");
	}
	
	abstract void soundHorn();
}

class kiaCar extends Car {
	
	void soundHorn(){
		System.out.println("Sound horn");
	}	
}

09-JUNE-2023
------------
interface Car {
	void driveCar();
	void soundHorn();
}
class KiaXCar implements Car {
	public void driveCar(){
		System.out.println("driving x car");
	}
	public void soundHorn(){
		System.out.println("sound x car horn");
	}
}
class KiaYCar implements Car {
	public void driveCar(){
		System.out.println("driving y car");
	}
	public void soundHorn(){
		usePopSoundDriverAndMakeSound();
	}
	public void usePopSoundDriverAndMakeSound(){
		System.out.println("sound y car horn");
	}
}
650- Car xCar = new KiaXCar();
651- xCar.driveCar();
652- xCar.soundHorn();

654- Car yCar = new KiaYCar();
655- yCar.driveCar();
656- yCar.soundHorn();

651-driving x car
652-sound x car horn
655-driving y car
656-sound y car horn

12-JUNE-2023
------------
4. Polymorphism

Polymorphism refers to many forms.
As per Polymorphism, We can perform one action in many ways.

to achieve Polymorphism, we have to use Interfaces and/or Abstract classes with Inheritance.

We have 2 types of Polymorphism,
-> Method overloading
-> Method overriding

Method: set of instructions given to perform specific functionality.

Method Syntax:
accessSpecifier returnType methodName(parameters) {
	// instructions
}

public void driveCar(int data){
	System.out.println("Driving car: "+data);
}

Every method has a Signature.

As part of method, we have Signature and Instructions

Signature refers to methodName, parameters of a method

methodName(parameters) {
	// instructions
}

Signature {
	// instructions
}

With respect to Signature->
	functionality does not matter,
	parameters names does not matter,
	number of parameter matters,
	parameter data type matters and
	parameter order matters

15-JUNE-2023
------------
-> Method overloading
Multiple methods with same name with different Signature is called Method overloading.
It is called Compile-time Polymorphism.
It is called Static Polymorphism.

public class NumberProcessor {
	public void addAndPrint(int data){
		int addedValue = data + 2;

		System.out.println(addedValue);
	}
	public void addAndPrint(double data){
		double addedValue = data + 2;

		System.out.println(addedValue);
	}
	public void addAndPrint(int x, int y){
		int addedValue = x + y + 78;

		System.out.println(addedValue);
	}
	public void addAndPrint(int data, double y){
		double addedValue = data + y + 78;

		System.out.println(addedValue);
	}
	public static void main(String[] array){
		NumberProcessor ref = new NumberProcessor();
		ref.addAndPrint(44);
		ref.addAndPrint(44, 66);
		ref.addAndPrint(44, 66.8);
	}
}

O/P:
46
46.7
188
188.8

16-JUNE-2023
------------
-> Method overriding

Method overriding is process having same method in Parent and child interface/class
- Parent and child class relationship(Inheritance) is mandatory
Same method: accessSpecifier returnType Signature
It is Runtime-Polymorphism.
It is called Dynamic Polymorphism.
Dynamic method dispatch.


interface Car {
	public abstract void driveCar();
	public abstract void soundHorn();
}
class KiaCar implements Car {
	public void driveCar() {
		System.out.println("Driving KiaCar");
	}
	public void soundHorn(){
		System.out.println("Making sound from KiaCar");
	}
}
class KiaXCar extends KiaCar {
	public void soundHorn(){
		System.out.println("Making sound from KiaXCar");
	}
}
public class MethodOverRidingSecondExample {
	public static void main(String[] arr){
		Car car = new KiaCar();
		
		car.driveCar();
		
		car.soundHorn();
		
		Car carX = new KiaXCar();
		
		carX.driveCar();
		
		carX.soundHorn();
	}
}

super keyword:
--------------
- super() is used in child class constructor to call Parent class constructor to initialize data members of parent class
- super keyword used to access data members of parent class in child class
- super keyword used to access methods of parent class in child class

class Parent {
	int number1 = 3;
	public void print(){
		System.out.println("Print from Parent: "+ number1);
	}
}
class Child extends Parent {
	public Child(){
		super();
		number1 = 8;
	}
	int number1 = 0;
	public void print(){
		super.print();
		System.out.println("Print from Child with parent Value: "+ super.number1);
		System.out.println("Print from Child: "+ (number1+2));
	}
}
public class NumberProcessor{
	public static void main(String[] array){
		Child ref = new Child();
		ref.print();
	}
}

