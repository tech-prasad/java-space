Java:
-----

30-MAY-2023
-----------

Processor is Hardware which understands only Binary numbers (0,1)

User instruction -> Calculator -> OS -> Processor
User instruction -> calculator -> OS System Routines -> Commands -> ZEROs and ONEs

Processor - 
Low level or Machine language - ZEROs and ONEs
Middle level or Assembly language - Commands
	Commands: add 2 2 , sub 2 2

OS -
System routines

Binary:
0 1 -> 0 1 2 3 4

0 - 0 0
1 - 0 1
2 - 1 0
3 - 1 1
4 - 1 0 0
8 - 1 0 0 0

1 1 1 1 1 1 1 1 - 255

2 power 0
2 power 1
2 power 2

Octal:
8 power 0
8 power 1
8 power 2

Decimal:
10 power 0
10 power 1
10 power 2

HexaDecimal:
16 power 0
16 power 1
16 power 2

0 15
0 .. 9 a b .. f


31-MAY-2023
-----------

Programing languages:
Java
C
C++
C#
SQL
Java-script

Java Programing Language:

What is Java?

Java is a High Level Programing Language

	High Level: Simple english like statements [object1.addAndPrint()]

	Simple english like statements -> OS -> Processor
	Simple english like statements -> OS System routines -> Commands -> ZEROs and ONEs

Java is a Object Oriented Programing Language (OOP)

	Object Oriented Programing Language has 4 Principles
	1. Encapsulation
	2. Inheritance
	3. Abstraction
	4. Polymorphism
	
What we can develop using Java?
	Standalone Applications, Web Applications, Enterprise Applications

Which company developed Java?
	Sun MicroSystem -> Oracle

Define Java?
	Java is a High level, Object oriented programming language and used to develop Standalone, Web and Enterprise Applications. It was developed by Sun MicroSystem and Now Owned by Oracle.

Explain Object oriented Programing Language Principles?

Object Oriented Programing Language has 4 Principles
	1. Encapsulation
	2. Inheritance
	3. Abstraction
	4. Polymorphism

1. Encapsulation - is the process of binding Data and Functionality together in Single Entity.
	By using class and object we achieve Encapsulation.
	
	Class -> Object 1, Object 2

	Logical - 
	Class { 
		data - data variable
		functionality: data + 2 - method
	}

	Physical - 
	Object 1 {
		data = 3
		functionality: 3+2=5
	}
	
	Object 2 {
		functionality: 0+2=2 <Note: data is 0 by default if we don't assign value>
	}

CODE EXAMPLE:
public class NumberProcessor {

	// Special method called Constructor
	public NumberProcessor(){
		// initialize the data members
		data = 44;
	}
		
	public int data;
	
	public void addAndPrint(){
		
		int addedValue = data + 2;
		
		System.out.println(addedValue);
	}
	
	public static void main(String[] array){
		
		NumberProcessor object1 = new NumberProcessor();
	
		object1.data = 3;
				
		object1.addAndPrint();
		
		NumberProcessor object2 = new NumberProcessor();
		
		object2.addAndPrint();
		
		NumberProcessor object3 = new NumberProcessor();
		
		object3.data = 78;
		
		object3.addAndPrint();	
	}
}

01-JUNE-2023
------------

Define Class?
Class is a logical structure which has set of Data members and Functionality.
Class is a logical structure which has set of Data members, Methods and Constructors.

Define Variable?
Variable is a name/reference to the memory location and holds the link to that memory location.

Define Method?
Method is a set of instructions to serve the Functionality.

Define Constructor?
Constructor is special method used initialize the data members.
Constructor will have the same name Class name.

Define Object?
Object is physical entity of the Class.
When we create Object, memory will be allocated to Data members of the class and Constructor will called and initialize the data members

02-JUNE-2023
------------

2. Inheritance
It is a process of acquiring the properties of Parent/Super class into Child/Sub class
It is a process of acquiring the Data and Functionality of Parent/Super class into Child/Sub class
It is a process of extending the properties of Parent class into Child class

The main goal of Inheritance is establishing Relationship, with that additionally we get to reuse some piece of code.

Inheritance is called "IS A" Relationship

Parent/Super/Base
Child/Sub/Derived

we need at least two classes:
Parent
Child

class Parent {

	public Parent(){
		vehicle = "Car";
	}
	
	String vehicle = "Car";
	
	public void drive(){
		System.out.println("Parent: "+vehicle);
	}
}

class Child extends Parent{
		
	public static void main(String[] array){
	
		Child object = new Child();
		
		object.drive();
	}
}

1. Single
2. Multi-Level
3. Hierarchical
4. Multiple
5. Hybrid

1. Single Inheritance
It is the process of one Child extending the properties of One Parent.

Parent -> Child

class Anil {
	
	String car;
	
	public Anil(){
		car = "Kia";
	
		System.out.println("Anil Constructor Called");
	}
	
	public void driveCar(){
		System.out.println("Driving car:"+car);
	}
}

class Bharat extends Anil {
	
	String bike;
		
	public void driveBike(){
		System.out.println("Driving bike:"+bike);
	}
}

public class Test {
	
	public static void main(String[] arr){
		
		Anil a = new Bharat();
		
		a.driveCar();
	}
}

2. Multi-Level
It is the Process of having Single Parent-Child Chain Relationship

Parent -> Child -> Child -> Child -> ...

class Anil {
	
	public Anil(){
		car = "Kia";
	
		System.out.println("Anil Constructor Called");
	}
	
	String car;
		
	public void driveCar(){
		System.out.println("Driving car:"+car);
	}
}

class Bharat extends Anil {
	
	String bike;
	
	public void driveBike(){
		System.out.println("Driving bike:"+bike);
	}
}

class Chandu extends Bharat {

	public Chandu() {
		super();
		phone = "Apple";
	}

	String phone;
	
	public void usePhone(){
		System.out.println("Use phone:" +phone);
	}
}

public class MLTest{
	
	public static void main(String[] array){
		
		Chandu c = new Chandu();
		
		c.phone = "MI";
		
		c.usePhone();
		
		c.driveBike();
		
		c.driveCar();
	}
}

Anil Constructor Called
Use phone:MI
Driving bike:null
Driving car:Kia

05-JUNE-2023
------------
3. Hierarchical Inheritance

It is the process of Single Parent and Multiple Child Chain Relationship.

Parent -> Child-1 and Child-2

Child-1 -> Child-11 and Child-12

class Anil {
	
	public Anil(){
		car = "Kia";
	
		System.out.println("Anil Constructor Called");
	}
	
	String car;
	
	public void driveCar(){
		System.out.println("Driving car:"+car);
	}
}

class Bharat extends Anil {
	
	String bike;
	
	public void driveBike(){
		System.out.println("Driving bike:"+bike);
	}
}

class John extends Anil {
		
	String computer = "DELL";

	public void workOnComputer(){
		System.out.println("Working on Computer: "+ computer);
	}
}

public class HirarchicalInheritance {
	
	public static void main(String[] a) {
		
		Bharat b = new Bharat();
		
		b.driveCar();
		
		b.bike = "Pulser";
		
		b.driveBike();
		
		John j = new John();
		
		j.car = "Maruthi";
		
		j.driveCar();
		
		j.workOnComputer();
		
		b.driveCar();
	}
}

Output:
Anil Constructor Called
Driving car:Kia
Driving bike:Pulser
Anil Constructor Called
Driving car:Maruthi
Working on Computer: DELL
Driving car:Kia

Interface:
----------
Interface is a contract to the class.

Abstract method is a method which does not have Functionality.

Interface is a contract to the class and it has set of Constants and Abstract methods.
Interface does not have Data members and Constructors.

Interface can be extends from another Interface.

Logical structure -> Real entity
Class -> Object

interface Car {
	
	int CONSTANT=1;

	void driveCar();
	void driveCarWith6Gears();
}

abstract class KiaCar implements Car {

	public void driveCar(){
		System.out.println("Driving Kia Car");
	}
}

class KiaXCar extends KiaCar {

	public void driveCarWith6Gears(){
		System.out.println("Driving Kia Car with 60KMPH");
	}
}

class KiaYCar extends KiaCar {

	public void driveCarWith6Gears(){
		System.out.println("Driving Kia Car with 100KMPH");
	}
}

public class InterfaceExample {

	public static void main(String[] a){
		
		Car c = new KiaXCar();
		
		c.driveCar();
		
		c.driveCarWith6Gears();
		
		Car cy = new KiaYCar();
		
		cy.driveCar();
		
		cy.driveCarWith6Gears();
	}
}

Driving Kia Car
Driving Kia Car with 60KMPH
Driving Kia Car
Driving Kia Car with 100KMPH

interface Horn {
	void soundHorn();
}

interface Car extends Horn {
	public abstract void driveCar();	
}

06-JUNE-2023
------------
4. Multiple Inheritance

It is the process of Single Child Having Multiple Parents

Child -> Parent 1 and Parent 2

By default Java does not support Multiple Inheritance with Classes.

We can achieve Multiple Inheritance in Java using Interfaces

07-JUNE-2023
------------
interface Car {
	public abstract void driveCar();	
}
class Horn {
	void soundHorn(){
		System.out.println("Horn sound");
	}
}
class KiaCar extends Horn implements Car {
	public void driveCar(){
		System.out.println("Driving Kia Car");
	}
}
public class MultipleInheritance {
	public static void main(String[] arr){
		KiaCar c = new KiaCar();
		
		c.soundHorn();
		c.driveCar();					
	}	
}

5. Hybrid Inheritance
---------------------
Hybrid Inheritance is a combination of Hierarchical Inheritance and Multiple Inheritance

Parent 1 -> Child 1, Child 2 --> Hierarchical Inheritance
Child 1, Child 2 -> Child 3 --> Multiple Inheritance

Anil -> Bharat , Chandu --> Hierarchical Inheritance
Bharat, Chandu -> Dharma --> Multiple Inheritance

Results in Hybrid Inheritance

interface Car {
	public abstract void driveCar();
}
interface Horn extends Car {
	void soundHorn();
}
class KiaCar implements Car {
	public void driveCar(){
		System.out.println("driveCar called");
	}
}
class KiaXCar extends KiaCar implements Horn {
	public void soundHorn(){
		System.out.println("soundHorn called");
	}
}
public class HybridInheritance {
	public static void main(String[] arr){
		KiaXCar c = new KiaXCar();
		c.soundHorn();
		c.driveCar();			
	}	
}

08-JUNE-2023
------------
// NumberProcessor is class name
public class NumberProcessor {

	// Special method called Constructor
	// NumberProcessor() is a Constructor
	public NumberProcessor(){
		// initialize the data members
		data = 44;
	}
	// data is instance variable	
	public int data;
	
	// addAndPrint() is a instance method definition
	// addAndPrint() is concrete method
	public void addAndPrint(){
		// addedValue is local variable
		int addedValue = data + 2;
		
		System.out.println(addedValue);
	}
	
	public static void main(String[] array){
		
		// new NumberProcessor() is a object or instance
		// object1 is a reference variable of type NumberProcessor and holding the object/instance // of NumberProcessor class
		NumberProcessor object1 = new NumberProcessor();
	
		// object1.data is assigning data instance variable using object1 reference variable
		object1.data = 3;
		
		// object1.addAndPrint(); is calling instance method using object1 reference variable
		object1.addAndPrint();
	}
}

3. Abstraction
--------------
Abstraction is process hiding unnecessary details and represent required details.

To achieve Abstraction, we have to use Interfaces and/or Abstract classes with Inheritance.

Interface: 
Interface is a contract to the class and it has set of Constants and Abstract Methods.
Abstract Method: Method with No definition. It has only Declaration
Constant: Constant is Variable which contains Constant Value which can not modify

Interface with no Methods is called Marker interface.
Marker interface: is a special interface used to give Special instructions to Java while creating the Object of child class of that Marker interface.

Abstract Class: is a class which contains data members and set of concrete methods and/or abstract methods.

For abstract class we can not create object.

abstract class Car {
	
	int data;
	
	void driveCar(){
		System.out.println("driving car");
	}
	
	abstract void soundHorn();
}

class kiaCar extends Car {
	
	void soundHorn(){
		System.out.println("Sound horn");
	}	
}

09-JUNE-2023
------------
interface Car {
	void driveCar();
	void soundHorn();
}
class KiaXCar implements Car {
	public void driveCar(){
		System.out.println("driving x car");
	}
	public void soundHorn(){
		System.out.println("sound x car horn");
	}
}
class KiaYCar implements Car {
	public void driveCar(){
		System.out.println("driving y car");
	}
	public void soundHorn(){
		usePopSoundDriverAndMakeSound();
	}
	public void usePopSoundDriverAndMakeSound(){
		System.out.println("sound y car horn");
	}
}
650- Car xCar = new KiaXCar();
651- xCar.driveCar();
652- xCar.soundHorn();

654- Car yCar = new KiaYCar();
655- yCar.driveCar();
656- yCar.soundHorn();

651-driving x car
652-sound x car horn
655-driving y car
656-sound y car horn

12-JUNE-2023
------------
4. Polymorphism

Polymorphism refers to many forms.
As per Polymorphism, We can perform one action in many ways.

to achieve Polymorphism, we have to use Interfaces and/or Abstract classes with Inheritance.

We have 2 types of Polymorphism,
-> Method overloading
-> Method overriding

Method: set of instructions given to perform specific functionality.

Method Syntax:
accessSpecifier returnType methodName(parameters) {
	// instructions
}

public void driveCar(int data){
	System.out.println("Driving car: "+data);
}

Every method has a Signature.

As part of method, we have Signature and Instructions

Signature refers to methodName, parameters of a method

methodName(parameters) {
	// instructions
}

Signature {
	// instructions
}

With respect to Signature->
	functionality does not matter,
	parameters names does not matter,
	number of parameter matters,
	parameter data type matters and
	parameter order matters

15-JUNE-2023
------------
-> Method overloading
Multiple methods with same name with different Signature is called Method overloading.
It is called Compile-time Polymorphism.
It is called Static Polymorphism.

public class NumberProcessor {
	public void addAndPrint(int data){
		int addedValue = data + 2;

		System.out.println(addedValue);
	}
	public void addAndPrint(double data){
		double addedValue = data + 2;

		System.out.println(addedValue);
	}
	public void addAndPrint(int x, int y){
		int addedValue = x + y + 78;

		System.out.println(addedValue);
	}
	public void addAndPrint(int data, double y){
		double addedValue = data + y + 78;

		System.out.println(addedValue);
	}
	public static void main(String[] array){
		NumberProcessor ref = new NumberProcessor();
		ref.addAndPrint(44);
		ref.addAndPrint(44, 66);
		ref.addAndPrint(44, 66.8);
	}
}

O/P:
46
46.7
188
188.8

16-JUNE-2023
------------
-> Method overriding

Method overriding is process having same method in Child class and Parent interface/class
- Parent and child class relationship(Inheritance) is mandatory
Same method: accessSpecifier returnType Signature
It is Runtime-Polymorphism - Method called at runtime based on Object created
It is called Dynamic Polymorphism - Method called based on objected
Dynamic method dispatch - Method called based on objected

interface Car {
	public abstract void driveCar();
	public abstract void soundHorn();
}
class KiaCar implements Car {
	public void driveCar() {
		System.out.println("Driving KiaCar");
	}
	public void soundHorn(){
		System.out.println("Making sound from KiaCar");
	}
}
class KiaXCar extends KiaCar {
	public void soundHorn(){
		System.out.println("Making sound from KiaXCar");
	}
}
public class MethodOverRidingSecondExample {
	public static void main(String[] arr){
		Car car = new KiaCar();
		
		car.driveCar();
		
		car.soundHorn();
		
		Car carX = new KiaXCar();
		
		carX.driveCar();
		
		carX.soundHorn();
	}
}

super keyword:
--------------
- super() is used in child class constructor to call Parent class constructor to initialize data members of parent class
- super(parameters) - is used in child class constructor to call parameterized constructor of the parent class
- super keyword used to access instance data members of parent class in child class
- super keyword used to access instance methods of parent class in child class

class Parent {
	int number1 = 3;
	public void print(){
		System.out.println("Print from Parent: "+ number1);
	}
}
class Child extends Parent {
	public Child(){
		super();
		number1 = 8;
	}
	int number1 = 0;
	public void print(){
		super.print();
		System.out.println("Print from Child with parent Value: "+ super.number1);
		System.out.println("Print from Child: "+ (number1+2));
	}
}
public class NumberProcessor{
	public static void main(String[] array){
		Child ref = new Child();
		ref.print();
	}
}

19-JUNE-2023
------------
Constructor Overloading:
It is the process of Multiple Constructors with different Signature
Example:
Parent()
Parent(int a)

class Parent {
	int number1;
	int number2;
	double number3;
	
	public Parent(){
	}
	public Parent(int a){
		number1 = a;
	}
	public Parent(int a, int b){
		number1 = a;
		number2 = b;
	}
	public Parent(int a, double b){
		number1 = a;
		number3 = b;
	}
	public Parent(int a, int b, double c){
		number1 = a;
		number2 = b;
		number3 = c;
	}
	public void print(){
		System.out.println("Print number1 from Parent: "+ number1);
		System.out.println("Print number2 from Parent: "+ number2);
		System.out.println("Print number3 from Parent: "+ number3);
	}
}
class Child extends Parent {
	int number1;
	
	public Child(){
		super();
		number1 = 99;
	}
	public Child(int a){
		super();
		number1 = 77;
	}
	public Child(int a, double c){
		super(a, c);
		number1 = 77;
	}	
	public void print(){
		super.print();
		System.out.println("Print from Child with parent Value: "+ super.number1);
		System.out.println("Print from Child: "+ (number1+2));
	}
}
public class NumberProcessor{
	public static void main(String[] array){
		Child ref = new Child();
		ref.print();
		
		Child ref1 = new Child(565);
		ref1.print();
		
		Child ref2 = new Child(12, 56.45);
		ref2.print();
	}
}

20-JUNE-2023
------------
this keyword:

this() - used to call zero parameterized constructor of the same class from another constructor
this(parameters) - used to call parameterized constructor of the same class from another constructor
this keyword used to access the instance variables of the same class
this keyword used to access the instance methods of same class
this refers to current object.

Both super and this can not be used at same in constructor.
Both super and this used to deal with only constructors, instance variables and instance methods

class Parent {
	int number1;
	int number2;
	
	public Parent(){
		this(1, 2);
		System.out.println("From zero parameterized constructor");
	}
	public Parent(int a){
		this();
		number1 = a;
	}
	public Parent(int a, int b){
		number1 = a;
		number2 = b;
	}
	public void print(){		
		System.out.println("Print number1 from Parent: "+ number1);
		System.out.println("Print number2 from Parent: "+ number2);
	}
}
class Child extends Parent {
	int number1;
	
	public Child(){
		super(33);
		number1 = 77;
	}
	public Child(int a){
		number1 = a;
	}
	public Child(int a, int c){
		this(a);
		number1 = a;
	}	
	public void print(){
		super.print();
		System.out.println("Print from Child with parent Value: "+ super.number1);
		System.out.println("Print from Child: "+ (number1+2));
	}
}
public class NumberProcessor2{
	public static void main(String[] array){
		Child ref = new Child(565, 4);
		ref.print();
		
	}
}

class Parent {
	int number1;
	int number2;
	
	public Parent(){
		this(1, 2);
		System.out.println("From zero parameterized constructor");
	}
	public Parent(int a){
		this();
		number1 = a;
	}
	public Parent(int a, int b){
		number1 = a;
		number2 = b;
	}
	public void print(){		
		System.out.println("Print number1 from Parent: "+ number1);
		System.out.println("Print number2 from Parent: "+ number2);
	}
}
class Child extends Parent {
	int number1;
	
	public Child(){
		super(33);
		number1 = 77;
	}
	public Child(int a){
		number1 = a;
	}
	public Child(int number1, int c){
		this(number1);
		this.number1 = number1;
	}	
	public void print(){
		super.print();
		System.out.println("Print from Child with parent Value: "+ super.number1);
		System.out.println("Print from Child: "+ (number1+2));
	}
	public void printNumbers(){
		int number1 = 58;
		System.out.println("Print Local variable: "+ (number1+2));
		System.out.println("Print Instance variable: "+ (this.number1+2));
		System.out.println("Print Instance variable from parent: "+ (super.number1+2));
	}
	public void useMethods(){
		this.print();
		super.print();
	}
}
public class ThisExample{
	public static void main(String[] array){
		Child ref = new Child(565, 4);
		ref.print();
		
	}
}

Object class
------------
Object is a class.
Object is a Predefined class in Java.
Every class in Java is a child of Object class directly or indirectly.
All classes are child classes of Object class directly or indirectly.

-- If we don't extend our class from any other class,
then compiler will give Object class as a default parent.

Object class has 9 methods as below

public class java.lang.Object {
  public java.lang.Object(); - Constructor
  public final native java.lang.Class<?> getClass();
  public native int hashCode();
  public boolean equals(java.lang.Object);
  protected native java.lang.Object clone();
  public java.lang.String toString();
  public final native void notify();
  public final native void notifyAll();
  public final void wait();
  public final native void wait(long);
  public final void wait(long, int);
  protected void finalize();
}

public class Calculator extends Object {
	public void add(){
		System.out.println(2+5);
		
		int hashCode = super.hashCode();
		
		System.out.println("Hashcode: "+hashCode);
	}
	public static void main(String[] arr){
		Calculator c = new Calculator();
		c.add();
	}
}

21-JUNE-2023
------------
Compilation process:
--------------------
In Java, we use "javac" command to compile the code.
Syntax: javac ClassName.java
Ex: javac Calculator.java

What happens when we compile code?
1. Check for Syntax and Semantic errors
	i. Java provided Keywords spelled correctly or not
	ii. Symbols like braces, dots, quotes, semi colon, etc
	iii. Variables used are present in class
	iv. Methods used are present in class
	v. Method declaration correct or not
	vi. Variable declaration correct or not
	
2. If class does not have any direct Parent it will add Object class as Parent
3. Default constructor will be added if there are no constructors defined
4. super() will be added as a first statement in Child Class Constructor if it is not added
5. When we implements interface, it will check, child class provided definition to all the interface abstract methods or not
6. If we create a object of a class and place it in other interface or class reference variable, then compiler check the relationship between the involved interface and classes
7. When we use a data member using reference variable, then compiler will check the variable is present in that class or its parent class, if its not there in that class or parent class then compiler will give error
8. When we call a method using reference variable, then compiler will check the method is present in that class or its parent class, if its not there in that class or parent class then compiler will give error
9. Once all checks complete and no errors found, compilation will be completed successfully

What happens when Compile completed successfully?
1. for every class one ".class" file will be created
   Name of ".class" file will be ClassName.class
   Ex: Calculator.class
2. If we have multiple classes declared in single .java file then after compilation,
   separate .class file will be created based on the number of classes present that .java file
3. In generated ".class" file, byte code will be placed

Who will use ".class" file?
1. Java will use the ".class" file
2. At the time of running code, Java uses ".class" file

22-JUNE-2023 / 23-JUNE-2023
---------------------------
Execution/Running process:
--------------------------
In Java, we use "java" command to run the code.
Syntax: java ClassName
Ex: java Calculator

What happens when we run the code?
JVM look for ".class" file with ClassName we provided
If JVM finds, ".class" file then Java look for main() method in Provided class

If JVM finds, main() method then it will start executing method by calling it
	Syntax of main() method Java look for:
	public static void main(String[] paramName){}

We should not give .class extension while running the code

JVM - Java Virtual Machine
--------------------------
JVM is a Execution Engine
JVM will run the Java Code

When we use 'java' command to run the code JVM gets started.
Once started memory will be allocated to JVM
If we create objects, memory will be allocated to objects in JVM

JVM has below components
------------------------
1. Class Loader
2. Runtime Data Area
3. Execution Engine
4. Java Native Interface
5. Garbage Collector

1. Class Loader
---------------
Class loader is used to Load the Class into JVM Memory(Method Area).
If the loaded class uses any other class then Class loader will load that class also.
Once class is loaded, it will identify Data members and Methods and memory will allocated.
Class loader only stores the Meta data of the class into memory.
Ex: class name, variable type and method names with definition, etc.
Once class is loaded in to JVM memory, If the class contains static variables, then memory will be allocated to static variables and initialized with default values or user given values

2. Runtime Data Area (JVM Memory)
	JVM Memory:
	-----------
	Method Area
	Heap
	Java Stack
	PC Register
	Native Method Stack

	Method Area Memory:
	Method area is used to allocate memory to meta data of the class
	Method area is used to allocate memory to the Local variables

	Heap Memory:
	When we create object, memory will be allocated inside Heap memory
	Heap Memory is used to allocate memory to Instance variables of the class and its Parent class

	Java Stack:
	Java Stack is used to hold the Currently executing User defined, predefined methods.
	If we call a method, method will be placed in Java Stack, from that method if we call any other method that also placed Java Stack
	Only User defined, predefined methods will be placed in Java Stack.

	PC Register:
	PC Register points to Currently executing instruction.

	Native Method Stack:
	Native Method is method coming from Other programming languages.
	Native Method Stack is used to hold the Currently executing native method.

3. Execution Engine
	Two components:
	---------------
	Interpreter
	JIT Compiler (Just-In-Time)

	Interpreter: 
	It is used to execute the instructions line by line
	It converts Java instructions into Machine level instructions/Machine Language
	It passes that Machine level instructions to Processor/CPU

	JIT Compiler: 
	It used to help Interpreter with Java Instructions which are already converted into Machine level instructions,
	So that Interpreter do not need to convert Java Instructions into Machine level instructions again and again.
	
	So with the help of JIT Compiler, Interpreter will execute instructions fastly by passing it to Processor.

4. Java Native Interface (JNI)
   JVM uses JNI to call Native methods
   
5. Garbage Collector
   It used to clean unused Objects in JVM Memory.
   When JVM shutdown, Garbage Collector cleanup all objects memory.
   In case if execution still progress but there are some unused objects are there which are Eligible for Garbage Collector to cleanup, in that case it is up to Garbage Collector, when to clean up those unused objects.

-----------------------
when we run java ThisExample
JVM starts and memory will be allocated to JVM

Class loader looks ThisExample.class file
once found, class loader loads ThisExample.class file in to JVM Memory(Method Area)
Memory will be allocated to Meta data of ThisExample class

JVM look for main method in ThisExample class
Once it found start executing

method will be placed in stack
PC register points to first instruction
Interpreter converts that instruction to machine level instruction
Interpreter passes that machine level instruction to Processor
----------------------------

26-JUNE-2023
------------
Object creation process:
------------------------
1. Object creation starts
2. Memory will be allocated to all instance data members
3. Initialize all the instance data members with default values
4. Constructor gets called to initialize instance data members with specific values
5. Object creation completed

static:
-------
static is key word in Java.
static is used to create class level data members and class level methods
static is used to create class level variables and class level methods

class level variable: it a is variable and will be declared with static key word and we call the variable as static variable
syntax:  static datatype variableName;
example: static int a; //- static variable a
Memory will be allocated to static variables at the time of class loading.
static variables gets initialized at the time of class loading.
We can access static variables with class name itself, no need to creating object.

27-JUNE-2023
------------
class level method: it is a method and will be declared with static key word and we call the method as static method.
syntax: static returnType signature(){}
example: static void main(){}

We can access static methods with class name itself, no need to creating object.

We are creating main method as static so while executing JVM will call main method directly by using provided class name with out creating object.

In side static method, we can not use instance variables and methods directly, but by creating object and with that reference we can use instance variables and methods in static method.

public class Student {
	int rollNumber;
	String studentName;
	int marks;	
	static String collegeName;
	
	public Student(){}
	public Student(int rollNumber, String studentName, int marks){
		this.rollNumber = rollNumber;
		this.studentName = studentName;
		this.marks = marks;
	}
	public void print() {
		System.out.printf("rollNumber: %d, studentName: %s, marks: %d, collegeName: %s\n", rollNumber, studentName, marks, collegeName);
	}
	public static void printCollegeName(){
		Student s = new Student(4, "Dharma", 675);
		
		System.out.printf("rollNumber: %d, studentName: %s, marks: %d, collegeName: %s\n", s.rollNumber, s.studentName, s.marks, collegeName);
		
		s.print();
	}
	public static void main(String[] arr){		
		Student.collegeName = "CBIT";
		
		Student.printCollegeName();
		
		Student s1 = new Student();
		s1.rollNumber = 2;
		s1.studentName = "Bharat";
		s1.marks = 678;	
		
		s1.print();		

		Student s2 = new Student(3, "Chandu", 555);
		s2.print();		
	}
}

Composition:
----------------------------
If we create a reference variable of a class in other class as instance variable then it is called Composition.
When we create Instance reference variable in a class then that relationship is called as "HAS A" relationship.
So Composition refers to "HAS A" relationship.

The main goal of Composition is re-usability.
We even can organize the code and modularize the code using Composition.

Address.java file:
class Address {
	String houseNumber;
	String city;
	String state;
	String country;
	
	Address(String houseNumber, String city, String state, 	String country){
		this.houseNumber=houseNumber;
		this.city=city;
		this.state=state;
		this.country=country;		
	}
	public void printAddress(){
		System.out.printf("%S, %S, %S, %S\n", houseNumber,city,state,country);
	}
}

Person.java file:
public class Person {
	String name;
	int age;
	String gender;
	Address address;
	
	Person(String name, int age, String gender, Address address){
		this.name=name;
		this.age=age;
		this.gender=gender;	
		this.address = address;
	}	
	public void print() {
		System.out.printf("%S, %d, %S, %S\n", name,age,gender,address.country);
		address.printAddress();
	}	
	public static void main(String[] arr){	
		
		Address addressReference = new Address("9-889", "Hydrabad", "Telangana", "India");
	
		Person p = new Person("Anil", 33, "Male", addressReference);
		
		p.print();
	}
}

package:
package is folder where we can group java files to modularize/organize code and provides easy access to the code.
We create packages based on functionality and group similar java files which serve that functionality.

By using packages, We can avoid Naming collision or Naming conflicts.

To create packages in java, we have to use 'package' keyword.

Package naming convention:
Syntax: package com.companydomain.projectname.modulename;
Example: package com.icicibank.netbank.payments;
		 package com.icicibank.netbank.common;
		 package com.icicibank.netbank.staff;

project
 -> com
	-> companydomain
		-> projectname
			-> modulename

netbank
 -> com
	 -> icicibank
		-> netbank
			-> staff
---------	
package com.icicibank.netbank.common;

public class Address {
	String houseNumber;
	String city;
	String state;
	String country;
	
	Address(String houseNumber, String city, String state, 	String country){
		this.houseNumber=houseNumber;
		this.city=city;
		this.state=state;
		this.country=country;		
	}
	public void printAddress(){
		System.out.printf("%S, %S, %S, %S\n", houseNumber,city,state,country);
	}
}			
---------
package com.icicibank.netbank.staff;

import com.icicibank.netbank.common.Address;

public class Manager {
	
	int managerId;
	String name;
	String email;
	String phoneNumber;
	Address address;
	
	public static void main(String[] arr){
		System.out.println("Manager testing");
	}	
}
---------
Compilation:
Syntax: javac -d . ClassName.java
Example: javac -d . Manager.java

Execution:
Syntax: java package.ClassName
Example: java com.icicibank.netbank.staff.Manager

Use classes from packages.
Syntax: import followed by package name;
Example: import com.icicibank.netbank.common.Address;

Java language also has predefined package.
Ex: 
java.lang
java.util

Object class is coming from java.lang package.

Use classes from predefined packages.
Syntax: import followed by package name;
Example: import java.lang.*
java.lang is default package every class imports

=========================
Assignments:
=========================
1. Student Management System

Address: flatNo, city, state, country

College: name, type, collegeAddess

Library: name, libraryAddess

Student: rollNumber, name, age, address, college, library

print(){
	System.println("Student details");
	System.println(rollNumber); 
	System.println(name); 
	System.println(age);
	System.println(studentAddess.flatNo);
	System.println(studentAddess.city);
	System.println(studentAddess.state);
	System.println(studentAddess.country);

	System.println("College details");
	System.println(college.name);
	System.println(college.type);
	System.println(college.collegeAddess.flatNo);
	System.println(college.collegeAddess.city);
	System.println(college.collegeAddess.state);
	System.println(college.collegeAddess.country);

	System.println("Library details");
	System.println(library.name);
	System.println(library.libraryAddess.flatNo);
	System.println(library.libraryAddess.city);
	System.println(library.libraryAddess.state);
	System.println(library.librarygeAddess.country);
}

StudentManagementSystem.java
main(){
Input:
	collegeAddess = Address("1-2222", "Hyderabad", "TS", "India");
	librayAddess = Address("1-2223", "Hyderabad", "TS", "India");
	studentAddess = Address("5-67", "Pune", "MH", "India");

	college = College("CBIT", "BTech", collegeAddess);

	library = Library("Abcaus", librayAddess);

	student = Student(1, "Anil", 23, studentAddess, college, library);

	student.print();
}
output:
Student details
1
Anil,
23,
5-67
Pune
MH
India

College details
CBIT
BTech
1-2222
Hyderabad
TS
India

Library details
Abcaus
1-2223
Hyderabad
TS
India

======================================

Calculator.java

a, b

add(){} + c = a + b; System.out.println("Add: "+ c);
sub(){} -
mul(){} *
div(){} /

main(){
	Calculator(2, 6);
	
	add();
	sub();
	mul();
	div();
}
=========================
30-JUNE-2023
Access Specifiers:
------------------
Access Specifier is decides visibility of Java components.
Access Specifier is decides way of accessing of Java components.
Access Specifier is decides visibility of classes, interfaces, constructors, variables and methods.

Also called as Access Modifiers.

1. public
2. protected
3. default
4. private

1. public:
public is keyword and acts a Access Specifier.

public applicable for classes, interfaces, constructors, variables and methods.

When we use public then we will get full visibility to access classes, interfaces, constructors, variables and methods.

When we use public, there are no restrictions applicable.

04-JULY-2023
------------
2. protected:
protected is keyword and acts a Access Specifier.

protected is applicable to constructors, variables and methods.

protected is not applicable to classes and interfaces.

When we use protected then we will get restricted visibility to access constructors, variables and methods.

If we use protected, visibility applicable for only that package.

So, if we use protected then they will be accessible with in the same package or child class from other package.

3. default:
There is no keyword to give default Access Specifier.
If we do not specify public protected, private then that is default access specifier.

default is applicable classes, interfaces, constructors, variables and methods.

If we use default, visibility applicable only in that package.

4. private:
private is a keyword and acts as Access Specifier.

private is applicable for Classes, Constructors, variables and methods.
private is not applicable for interfaces.

if we use private, visibility applicable only in that class.

Visibility:
public :- any where(No Restriction)
protected :- with in the package and child classes of other package
												(Limited Restriction)
default :- with in the package only (Limited Restriction)
private :- with in the class only (Full Restriction)

Applicable:
public :- Classes, Interfaces, Constructors, Variables and Methods.
protected :- Constructors, Variables and Methods.
default :- Classes, Interfaces, Constructors, Variables and Methods.
private :- Classes, Constructors, Variables and Methods.

Access Modifiers:
-----------------
Access Modifiers alter the way of accessing Java components.
Access Modifiers alter the way of accessing Classes, Variables and Methods.

final:
final is a keyword and acts as a access modifier.

final is used with class to restrict "IS A" relationship(Inheritance).

final class can not extend to child class.
by using final with class, we can enforce composition over inheritance.

final is used with method to restrict method overriding.

final is used with variables to create constant variables.
Once constant variable is initialized, value can not modified.

We can initialize final variables at the time declaration or We can initialize final variables in constructor.

If We initialize final variables at the time declaration then we can not assign the value to final variables in constructor.

If We don't initialize final variables at the time declaration then we can initialize the value to final variables in constructor.

final variables must be initialized.

If we have multiple constructors, then in every constructor we have to initialize final variables.

static:
-------
static is key word in Java and acts as a access modifier.
static is used to create class level data members and class level methods
static is used to create class level variables and class level methods

class level variable: it a is variable and will be declared with static key word and we call the variable as static variable
syntax:  static datatype variableName;
example: static int a; //- static variable a
Memory will be allocated to static variables at the time of class loading.
static variables gets initialized at the time of class loading.
We can access static variables with class name itself, no need to creating object.

abstract:
abstract is key word in Java and acts as a access modifier.
by using abstract keyword we can create abstract methods and abstract classes.

Eclipse IDE: 
------------
Full form Integrated development environment.

We can project easily.
We can create package to organize code easily.
We can create classes faster with some code already placed.
We can take help of auto suggestions.
We can take help of auto completions.
Automatically code gets compiled and errors shown to developer.
If there is no error compilation gets success and .class file creates automatically.
We can generate some code like,
System.out.println,
main method and etc.
We can easily run the code.

Data types:
-----------
Data types used to create variables.
Data type decides which type of data can be stored in the variable.

There are 2 types Data types.
1. Primitive data types
2. Non-Primitive data types

1. Primitive data types
-----------------------
Primitive data types are used to create normal variables.
All Primitive data types are coming from Java.
There are 8 different Primitive data types,
1. byte
2. short
3. int
4. long
5. float
6. double
7. boolean
8. char

byte, short, int, long, float, double are number data types, so that we can store numbers.

1. byte: Primitive data type
byte is a keyword and used to store 8 bit signed integers from (-128 to +127).
default value: 0 (Zero)

2. short: Primitive data type
short is a keyword and used to create variables which can store 16 bit signed integers from (-32768 to +32767).
default value: 0 (Zero)

3. int: Primitive data type
int is a keyword and used to create variables which can store 32 bit signed integers from (-2 billion to +2 billion).
default value: 0 (Zero)

4. long: Primitive data type
long is a keyword and used to create variables which can store 64 bit signed integers from (more than int).
default value: 0L (Zero)

5. float: Primitive data type
float is keyword and used to create variables which can store 32 bit signed floating point numbers.
default value: 0.0f

6. double: Primitive data type
double is a keyword and used to create variables which can store 64 bit signed floating point numbers.
default value: 0.0

Boolean types:
7. boolean: Primitive data type
boolean is a keyword and used to create variables which can store boolean values (true, false)
default value: false

Character Types:
8. char: Primitive data type
char is a keyword and used to create variables which can store single Character.
default value: null character ('\u0000')

public class Numbers {

	public byte byteVariable = 126;
	public short shortVariable = -32765;
	public int intVariable = 999999999;
	public long longVariable = 99999999909546456L;
	public float floatVariable = 45.7f;
	public double doubleVariable = 99.77;

	public boolean isActive = true;

	public char gender = 'M';

	public void print() {
		System.out.println("byteVariable: " + byteVariable);
		System.out.println("shortVariable: " + shortVariable);
		System.out.println("intVariable: " + intVariable);
		System.out.println("longVariable: " + longVariable);
		System.out.println("floatVariable: " + floatVariable);
		System.out.println("doubleVariable: " + doubleVariable);
		System.out.println("isActive: " + isActive);
		System.out.println("gender: " + gender);
	}	
	public static void main(String[] args) {
		Numbers numbers = new Numbers();
		numbers.print();
	}
}

There are 8 different Primitive data types,
1. byte
2. short
3. int
4. long
5. float
6. double
7. boolean
8. char

In Java, Every Primitive data type has corresponding Wrapper class.
Wrapper class:
Wrapper class is a predefined class which represents Corresponding primitive data type in Object format.
When we use Wrapper class, we can get additional functionality.
Example: convert String number into byte value. 

1. byte: Corresponding wrapper class for "byte" is "Byte" class. 
2. short: Corresponding wrapper class for "short" is "Short" class.
3. int: Corresponding wrapper class for "int" is "Integer" class.
4. long: Corresponding wrapper class for "long" is "Long" class.
5. float: Corresponding wrapper class for "float" is "Float" class.
6. double: Corresponding wrapper class for "double" is "Double" class.
7. boolean: Corresponding wrapper class for "boolean" is "Boolean" class.
8. char: Corresponding wrapper class for "char" is "Character" class.

public class Numbers {

	public Byte byteVariable = 126;
	public Short shortVariable = -32765;
	public Integer intVariable = 999999999;
	public Long longVariable = 99999999909546456L;
	public Float floatVariable = 45.7f;
	public Double doubleVariable = 99.77;

	public Boolean isActive = true;

	public Character gender = 'M';

	public void print() {
		System.out.println("byteVariable: " + byteVariable);
		System.out.println("shortVariable: " + shortVariable);
		System.out.println("intVariable: " + intVariable);
		System.out.println("longVariable: " + longVariable);
		System.out.println("floatVariable: " + floatVariable);
		System.out.println("doubleVariable: " + doubleVariable);
		System.out.println("isActive: " + isActive);
		System.out.println("gender: " + gender);
	}

	public static void main(String[] args) {
		Numbers numbers = new Numbers();
		numbers.print();
	}
}

2. Non-Primitive data types (Reference type)
---------------------------
Non-Primitive data type store Object Reference.
Non-Primitive data types are Predefined classes of Java or User defined classes.
If we create a Class, then that class is a User defined data type.
Default value for all Non-Primitive data type variables is null.
Example: 
String, Student, College, etc.

Type casting:
-------------
Type casting is the process of converting one data type into another data type.

1. Primitive data type casting
2. Non-Primitive data type casting

1. Primitive data type casting
------------------------------
It is the process converting one primitive data type into another primitive data type.

implicit type casting:
If we type cast lower size data type to higher size data type then that is called implicit type casting. Java do this type casting automatically.
	public void print() {
		int intVariable = 8;
		long value = intVariable;
		
		System.out.println(value);
	}

explicit type casting:
If we type cast higher size data type to lower size data type then that is called explicit type casting.
In explicit type type casting, Java will not do type casting automatically.
Developer has to do type casting manually.
	public void print() {
		double doubleVariable = 9.8;
		int value = (int)doubleVariable;
		
		System.out.println(value);
	}
There is a chance of data loss.	

2. Non-Primitive data type casting
----------------------------------
Converting one class object reference to another class object reference.

Up-Casting:
Child object placed in Parent reference variable.
Java do Up-Casting automatically.

	Parent reference = new Child();

Down-Casting:
Parent object reference placed in Child reference variable.
Java will not do Down-Casting automatically.

	Parent reference = new Child();
	Child c = (Child)reference;
In the above example, child object placed in parent reference and casting to child again, which is fine because parent is holding child object only and copied to child reference with down casting.

	Parent reference = new Parent();
	Child c = (Child)reference;
In the above example, parent object placed in parent reference and casting to child which is not fine because parent is holding parent object which we can not copied to child reference.
If we do that by down casting, compiler will allow but at runtime we will get ClassCastException error.
If classes are not related then also Type cast results in ClassCastException error.

Java naming conventions:
------------------------
Convention: Best practice, so that everyone understand and it makes it more readable.

Class/Interface naming convention:
----------------------------------
Every Class name should be meaningful which represents the data, functionality.
Every Class name should follow Camel case and First letter should be Uppercase.
There are no spaces allowed and no special characters allowed.
Example:
	Student
	StudentManagementSystem

Class and Interface naming convention is same.

Variable naming convention:
---------------------------
Every Variable name should be meaningful which represents the data.
Every Variable name should follow Camel case and First letter should be Lowercase.
Example: 
	rollNumber
	studentName
	age

Method naming convention:
-------------------------
Every method name should be meaning full which represents functionality.
Every method name should follow Camel case and First letter should be Lowercase.
Example:
	main()
	printStudentAddress()

Constant naming convention:
---------------------------
Every constant name should be meaningful which represents the data.
Every constant name should be Uppercase and Each word should separated with Underscore(_).
Example:
    COLLEGE_NAME

Boolean variable naming convention:
-----------------------------------
Every Boolean Variable name should be meaningful which represents the data.
Every Boolean Variable name should follow Camel case and First letter should be Lowercase.
We have to use question type name.
Example:
	isAcvtive
	hasPermission
	
Package naming convention:
--------------------------
Package name should be in lower case.
Each word separated with dot(.).

Convention:
project
 -> com
	-> companydomain
		-> projectname
			-> modulename
			
Example:
	com.icicibank.netbank.payments
	
Accessor methods:
-----------------
Accessor methods are the methods which are used to access data members of the class.
All the data members we declare as private and use them with Accessor methods.
Two types of Accessor methods:
set Accessor methods, also called as setters,
get Accessor methods, also called as getters.
Data members should be private and corresponding Accessor methods should be public.
We use setters to assign the values and getters to get the values.
We can assign and get values multiple times with setters and getters.
syntax:
	setVariableName - (setName(String name))
	getVariableName - (getName())

public class College {
	private String name;
	private String type;
	private Address collegeAddress;

	public void setName(String name) {
		this.name = name;
	}
	public String getName() {
		return name;
	}
	public void setType(String type) {
		this.type = type;
	}
	public String getType() {
		return type;
	}
	public void setCollegeAddress(Address collegeAddress) {
		this.collegeAddress = collegeAddress;
	}
	public Address getCollegeAddress() {
		return collegeAddress;
	}
}

11-JULY-2023
------------
Operators and Expressions:
1. Arithmetic operators
2. Assignment operators
3. Comparison/Conditional operators
4. Logical operators
5. Ternary operator
6. instanceof operator
7. Method invocation operator
8. Concatenating operator
9. Bitwise operators

Operator: Operator is a Symbol or Special Character which Performs Specific Operation.
Operand: Operand is a Variable or a Constant on which Operator can Perform Operation.
Expression: It is a combination of Operators and Operands.

1. Arithmetic operators
-----------------------
Arithmetic operators used to perform Arithmetic calculations on numbers.
Outcome: Numbers
a. Addition (+)
b. Subtraction (-)
c. Multiplication (*)
d. Division (/)
e. Module (Reminder) (%)
f. Increment (++)
g. decrement (--)

a. Addition (+):
----------------
to perform Addition, we need at least two variables (operands).

Syntax: 
operand1 + operand2
operand1 + operand2 + operand3

Example:
a + b
1 + 5
a + b + c
a + 7
a + 7 + d

b. Subtraction (-):
-------------------
to perform Subtraction, we need at least two variables (operands).

Syntax: 
operand1 - operand2
operand1 - operand2 - operand3

Example:
a - b
1 - 5
a - b - c
a - 7
a - 7 - d

c. Multiplication (*):
----------------------
to perform Multiplication, we need at least two variables (operands).

Syntax: 
operand1 * operand2
operand1 * operand2 * operand3

Example:
a * b
1 * 5
a * b * c
a * 7
a * 7 * d

d. Division (/):
----------------
to perform Division, we need at least two variables (operands).

Syntax: 
operand1 / operand2 / operand3

Example:
a / b
1 / 5
a / 7

e. Module (Reminder) (%):
to perform Module (Reminder), we need at least two variables (operands).

Syntax: 
operand1 % operand2 % operand3

Example:
a % b
1 % 5
a % 7

f. Increment (++)
-----------------
to perform Increment, we need single variable (operand).

it is a shorthand of addition of adding 1.

Syntax:
Variable++
++Variable

Example:
number = 10
number++ (number = number + 1) - Post increment
++number (number = number + 1) - Pre increment

g. Decrement (--)
-----------------
to perform Decrement, we need single variable (operand).

it is a shorthand of Subtraction to reduce value by 1.

Syntax:
Variable--
--Variable

Example:
number = 10
number-- (number = number - 1)
--number (number = number - 1)

Example code:
package com.operators.arithmetic;

public class ArithmeticOperators {

	public static void main(String[] args) {

		int a = 3;
		int b = 5;
		int c = 8;

		int add = a + b + c + 99;

		System.out.println("Add: " + add);

		int sub = a - b - c - 67;

		System.out.println("Sub: " + sub);

		int mul = a * b * c * 2;

		System.out.println("Mul: " + mul);

		int div = 2000 / a / b / c;

		System.out.println("Div: " + div);

		int percent = 2000 % a % b % c;

		System.out.println("Percent: " + percent);

		int x = 10;

		System.out.println("X: " + x);

		int z = x++;

		System.out.println("Z: " + z);
		System.out.println("X: " + x);

		int i = 7;

		System.out.println("I: " + i);

		int k = ++i;

		System.out.println("K: " + k);
		System.out.println("I: " + i);

		int p = 6;

		System.out.println("P: " + p);

		++p;

		System.out.println("P: " + p);

		int n = 9;

		System.out.println("N: " + n);

		int q = n--;

		System.out.println("Q: " + q);
		System.out.println("N: " + n);

		int u = 4;

		System.out.println("U: " + u);

		int v = --u;

		System.out.println("V: " + v);
		System.out.println("U: " + u);

		int h = 8;

		System.out.println("H: " + h);

		System.out.println("H: " + --h);
	}
}

2. Assignment operators
-----------------------
Assignment operators are used to assign the values.

a. = (Outcome depends on what value we keep in it)
b. += (Numbers)
c. -= (Numbers)
d. *= (Numbers)
e. /= (Numbers)
f. %= (Numbers)

Example code:
package com.operators.assignment;

public class AssignmentOperators {
	public static void main(String[] args) {

		String value = "Working fine";

		int a = 8;

		System.out.println("a: " + a);

		int b = 3;

		b += a; // b = b + a;

		System.out.println("a: " + a);
		System.out.println("b: " + b);

		int c = 5;

		c -= a; // c = c - a;

		System.out.println("a: " + a);
		System.out.println("c: " + c);

		int d = 4;

		d *= a; // d = d * a;

		System.out.println("a: " + a);
		System.out.println("d: " + d);

		int e = 16;

		e /= a; // e = e / a;

		System.out.println("a: " + a);
		System.out.println("e: " + e);

		int f = 67;

		f %= a; // f = f % a;

		System.out.println("a: " + a);
		System.out.println("f: " + f);
	}
}

3. Comparison/Conditional operators
-----------------------------------
Comparison/Conditional operators are used to compare 2 different values.
Outcome: true or false

a. == (equal)
used to find the equality of 2 operands, return true if the 2 operands are equal.

b. != (not equal)
used to find the in-equality of 2 operands, return true if the 2 operands are not equal.

c. > (greater than)
used to find the greater than of 2 operands, return true if the operand1 is greater than operand2.

d. >= (greater than or equal)
used to find the greater than or equal of 2 operands, return true if the operand1 is greater than or equal to operand2.

e. < (less than)
used to find the less than of 2 operands, return true if the operand1 is less than operand2.

f. <= (less than or equal)
used to find the less than or equal of 2 operands, return true if the operand1 is less than or equal to operand2.

Example code:
package com.operators.comparison;

public class ComparisonOperators {
	public static void main(String[] args) {

		int x = 5;

		boolean a = x == 5;
		System.out.println("a: " + a);

		boolean b = 7 == 5;
		System.out.println("b: " + b);

		boolean c = 5 != 5;
		System.out.println("c: " + c);

		boolean d = 7 != 5;
		System.out.println("d: " + d);

		boolean e = 5 > 5;
		System.out.println("e: " + e);

		boolean f = 7 > 5;
		System.out.println("f: " + f);

		boolean g = 5 >= 5;
		System.out.println("g: " + g);

		boolean h = 7 >= 5;
		System.out.println("h: " + h);

		boolean i = 4 >= 5;
		System.out.println("i: " + i);

		boolean j = 5 < 5;
		System.out.println("j: " + j);

		boolean k = 4 < 5;
		System.out.println("k: " + k);

		boolean m = 7 < 5;
		System.out.println("m: " + m);

		boolean n = 5 <= 5;
		System.out.println("n: " + n);

		boolean p = 7 <= 5;
		System.out.println("p: " + p);

		boolean q = 4 <= 5;
		System.out.println("q: " + q);
	}
}

12-JULY-2023
------------
4. Logical operators
--------------------
Used to perform logical operations on Boolean input.
Input: true or false
Outcome: true or false

a. AND: &&
b. OR: ||
c. NOT: !

Example code:
package com.operators.logical;

public class LogicalOperators {
	public static void main(String[] args) {

		boolean a = false;
		boolean b = true;

		boolean e = a && a;
		boolean f = a && b;
		boolean g = b && a;
		boolean h = b && b;

		System.out.println("AND Example:");
		System.out.println(a + " " + a + " " + e);
		System.out.println(a + " " + b + " " + f);
		System.out.println(b + " " + a + " " + g);
		System.out.println(b + " " + b + " " + h);

		boolean i = a || a;
		boolean j = a || b;
		boolean k = b || a;
		boolean m = b || b;

		System.out.println();
		System.out.println("OR Example:");
		System.out.println(a + " " + a + " " + i);
		System.out.println(a + " " + b + " " + j);
		System.out.println(b + " " + a + " " + k);
		System.out.println(b + " " + b + " " + m);

		boolean n = !a;
		boolean p = !b;

		System.out.println();
		System.out.println("NOT Example:");
		System.out.println(a + " " + n);
		System.out.println(b + " " + p);

		System.out.println();
		boolean q = 1 == 7;
		boolean r = 7 == 7;

		boolean s = r || q;
		System.out.println("s: " + s);

		boolean t = q && r;
		System.out.println("t: " + t);

		boolean u = 5 > 3 && r;
		System.out.println("u: " + u);

		boolean v = 5 < 6 && 7 > 6;
		System.out.println("v: " + v);

		boolean w = 8 < 9 || 4 > 3;
		System.out.println("w: " + w);

		boolean x = !(6 > 7);
		System.out.println("x: " + x);

		boolean y = (3 > 5 && 5 < 4) || 7 > 5;
		System.out.println("y: " + y);

		boolean z = 3 > 5 && (5 < 4 || 7 > 5);
		System.out.println("z: " + z);

		boolean ab = !(3 > 5 && (5 < 4 || 7 > 5));
		System.out.println("ab: " + ab);
	}
}

5. Ternary operator (?:)
------------------------

input: true or false
Outcome: Anything
Example:
package com.operators.ternary;

public class TernaryOperator {
	public static void main(String[] args) {

		int a = 10;
		int b = 20;

		boolean c = a > b;

		int d = c ? 123 : 345;

		System.out.println("d: " + d);

		int e = 45 > 44 ? 123 : 345;

		System.out.println("e: " + e);

		int f = c && (45 > 44) ? 123 : 345;

		System.out.println("f: " + f);
		
		int g = !(!c && (45 > 44)) ? 123 : 345;

		System.out.println("g: " + g);
		
		String t = c ? "Apple" : "Google";

		System.out.println("t: " + t);
		
		String v = !c ? "Apple" : "Google";

		System.out.println("v: " + v);
	}
}
13-JULY-2023
------------
6. instanceof operator
----------------------
it is used compare the reference variable against a Object of a Class.
return true, if the reference is referring the given class object or child class object.
Outcome: true or false
Example code:
package com.operators.instance.of;

interface Car {
	void driveCar();
	void soundHorn();
}
abstract class KiaCar implements Car {
	public void driveCar() {
		System.out.println("Driving Kia Car");
	}
}
class KiaXCar extends KiaCar {
	public void soundHorn() {
		System.out.println("Sound horn Kia X Car");
	}
}
class kiaYCar extends KiaCar {
	public void soundHorn() {
		System.out.println("Sound horn Kia Y Car");
	}
	public void openRoofTop() {
		System.out.println("Open roof of Kia Y Car");
	}
}
public class VehicleSystem {	
	public void useCar(Car c) {
		c.driveCar();
		c.soundHorn();

		if (c instanceof kiaYCar) {
			kiaYCar yCar = (kiaYCar) c;
			yCar.openRoofTop();
		}
	}	
	public static void main(String[] args) {
		VehicleSystem v = new VehicleSystem();

		KiaXCar xCar = new KiaXCar();

		v.useCar(xCar);
		
		kiaYCar yCar = new kiaYCar();

		v.useCar(yCar);			
	}
}

7. Method invocation operator
-----------------------------
dot (.) is method invocation operator

Student s = new Student();
s.getStudentName(); // here dot(.) used to call method of student class
s.age // here dot(.) used to use variable of student class

8. Concatenating operator
-------------------------
+ is a Concatenating operator.
Concatenation: Combining two or more data together.

Example code:
package com.operators.concatenation;

public class ConcatenationOperator {
	public static void main(String[] args) {
		String x = "ABC";
		String y = "DEF";
		String z = x + y + "PQR"; // ABCDEFPQR

		System.out.println(z);

		String i = x + 7 + "IJK" + 4; // ABC7IJK4

		System.out.println(i);

		String u = y + (6 + 7) + "UVW" + 6 + (8 + 9); // DEF13UVW617

		System.out.println(u);
	}
}

14-JULY-2023
------------
9. Bitwise operators
--------------------
Bitwise operators perform operation on numbers in the form bits.

a. Bitwise AND: &
b. Bitwise OR: |
c. Bitwise XOR: ^
d. Bitwise NOT: ~ (Complement)
e. Left Shift: <<
f. Right Shift: >>
g. Unsigned Right Shift: >>>

a. Bitwise AND: &
-----------------
5 & 3
5 = 0101
3 = 0011
1 = 0001

5 & 3 = 1

b. Bitwise OR: |
----------------
5 | 3
5 = 0101
3 = 0011
7 = 0111

5 | 3 = 7

c. Bitwise XOR: ^
-----------------
5 ^ 3
5 = 0101
3 = 0011
6  = 0110

5 ^ 3 = 6

d. Bitwise NOT: ~ (Complement)
------------------------------
~1
1 =  001
-2 = 110

e. Left Shift: <<
-----------------
5 << 2
5 = 00000000000000000000000000000101
5 << 2 = 00000000000000000000000000010100
5 << 2 = 20

f. Right Shift: >>
------------------
-20 >> 2
-20 = 10000000000000000000000000010100
-20 >> 2 = 10000000000000000000000000000101
-20 >> 2 = -5

g. Unsigned Right Shift: >>>
----------------------------
-4 >>> 2
4 = 00100000000000000000000000000001

Example code:
-------------
package com.operators.bitwise;

public class BitwiseOperators {
	public static void main(String[] args) {

		int a = 5;
		int b = 3;

		int c = a & b;
		System.out.println("& c: " + c);

		int d = a | b;
		System.out.println("| d: " + d);

		int f = a ^ b;
		System.out.println("^ f: " + f);

		int e = ~1;
		System.out.println("~ e: " + e);

		int g = 5 << 2;
		System.out.println("<< g: " + g);

		int h = -20 >> 2;
		System.out.println(">> h: " + h);

		int i = -4 >>> 2;
		System.out.println(">>> i: " + i);
	}
}

Assignment:
Address - properties - Accessor methods
College - properties - Accessor methods
Library - properties - Accessor methods
Student - properties - Accessor methods
Student add marks, add getTotalMarks(), getAvarage(), isPassed()

StudentManagementSystem
Address collegeAddress = new Address()
collegeAddress.setHouseNumber(1);

College college = new College();
college.setName("CBIT");
college.setType("BTECH");
college.setCollegeAddress(collegeAddress);

Address libraryAddress = new Address()
libraryAddress.setHouseNumber(1);

Library library = new Library();
library.set()
library.setLibraryAddress(libraryAddress);

Output:
Student details
123
Anil
23
flatNo: 5-456, city: MUMBAI, state: MH, country: INDIA
College details
CBIT
BTECH
flatNo: 1-77, city: HYD, state: TS, country: INDIA
Library details
Abcus
flatNo: 1-78, city: HYD, state: TS, country: INDIA

Result:
Print all marks: 
Print total marks:
Print average:
Print Passed/Failed

Control Structures:
Conditional Structures:
-----------------------
Used to control the flow of execution.
All the Control Structures work based on boolean (true or false) based conditions.

a. if
b. if-else
c. if - else if
d. switch
e. for
f. while
g. do-while

a. if condition
---------------
"if" condition is used to control the single flow of execution.
only if block execute when condition is true.
false do nothing

Syntax: 
if(condition){
	// Instructions
}

Nested if:
if(condition){
	// Instructions
	if(condition){
		// Instructions
	}
}

Example code:
package com.control.structures;

public class SchoolBell {
	public void ringBell() {
		System.out.println("Ring the bell");
	}
	public static void main(String[] args) {
		SchoolBell bell = new SchoolBell();

		int time = 4;

		if (time == 4) {
			bell.ringBell();
		}
	}
}

b. if-else condition
--------------------
"if-else" condition is used to control the flow of execution of two blocks.
condition true: execute if block
condition false: execute else block

Syntax: 
if(condition){
	// Instructions
} else {
	// Instructions
}

Example code:
package com.control.structuresifelse;

public class ATM {
	public static void main(String[] args) {

		int accountBalance = 500;

		int wantToWithdraw = 500;

		if (wantToWithdraw <= accountBalance) {
			System.out.println("Withdraw success for amount: " + wantToWithdraw);
		} else {
			System.err.println("Withdraw failed for amount (Insufficient Balance): " + wantToWithdraw);
		}
	}
}

17-JULY-2023
------------
c. if - elseif condition:
-------------------------
"if - else if" condition is used to control flow of execution of multiple blocks.

Syntax: 
if(condition) {
	//instructions
} else if(condition){
	//instructions
} else if(condition){
	//instructions
} else {
	//instructions
}

Example code:
package com.control.structuresifelseif;

public class NumberSystem {
	public static void main(String[] args) {

		int number = 0;

		if (number > 0) {
			System.out.println("Given number is Positive: " + number);
		} else if (number < 0) {
			System.out.println("Given number is Negative: " + number);
		} else {
			System.out.println("Given number is Zero");
		}
	}
}

d. switch
---------
Used to control the flow of execution of multiple blocks.
case: it is a label which matched switch value.
break: it used to stop executing further case statement instruction.
default: if non of case matched then default case will be executed and default should be the last case.

allowed data types: int, byte, short, char, Integer, Byte, Short, Character, String.

syntax:
switch(variable) {
	case label-1: 
	//instructions
	break; // End of: case label-1
	case label-2: 
	//instructions
	break;
	...
	default:
	//instructions
}
Example code:
package com.control.switchex;

public class NumberSystem {
	public static void main(String[] args) {

		int number = 1;

		switch (number) {
		case 1:
			System.out.println("Given number is One");
			break;
		case 2:
			System.out.println("Given number is Two");
			break;
		case 3:
			System.out.println("Given number is Three");
			break;
		case 4:
			System.out.println("Given number is Four");
			break;
		case 5:
			System.out.println("Given number is Five");
			break;
		case 6:
			System.out.println("Given number is Six");
			break;
		case 7:
			System.out.println("Given number is Seven");
			break;
		case 8:
			System.out.println("Given number is Eight");
			break;
		case 9:
			System.out.println("Given number is Nine");
			break;
		case 0:
			System.out.println("Given number is Zero");
			break;
		default:
			System.out.println("Given number is Not sure");
			break;
		}
	}
}

18-JULY-2023
------------
e. for
------
for is looping control structure and used to execute some piece of code multiple times until some condition met.
Syntax:
for(initialization; condition; increment/decrement){
	// instructions
}
initialization: only once before loop start
condition: every time before starting loop
increment/decrement: every time after the loop execution

Example code:
package com.loop.forex;

public class NumberSystem {
	public static void main(String[] args) {
		for (int a = 1; a <= 9; a++) {
			System.out.println(a);
		}
		System.out.println("test");
		for (int x = 9; x >= 0; x--) {
			System.out.println(x);
		}
	}
}

Nested for:
for(initialization; condition; increment/decrement){
	// instructions
	for(initialization; condition; increment/decrement){
		// instructions
	}
}
Example code:
package com.loop.nestedforex;

public class NestedForLoopExample {
	public static void main(String[] args) {

		for (int a = 1; a <= 10; a++) {

			for (int b = 1; b <= 10; b++) {

				System.out.println(a + b);
			}
		}
	}
}


f. while:
---------
while is looping control structure and used to execute some piece of code multiple times until some condition met.

syntax:
while(condition){
	// instructions
}
condition: every time before starting loop

Example code:
package com.loop.whileex;

public class NumberSystem {
	public static void main(String[] args) {

		int i = 1;

		while (i < 10) {
			System.out.println(i);

			i++;
		}
		System.out.println("test\n");

		int p = 9;

		while (p >= 0) {
			System.out.println(p);
			p--;
		}
	}
}

Nested while:
while(condition){
	// instructions
	while(condition){
		// instructions
	}
}

g. do-while:
------------
do-while is looping control structure and used to execute some piece of code multiple times until some condition met.
do-while first execute instructions then check the condition.
Due to this, even though condition is false for the first time, still loop execute once.

condition: Every time after completing loop.
syntax:
do {
	// instructions
}while(condition);

Example code:
package com.loop.dowhileex;

public class NumberSystem {
	public static void main(String[] args) {

		int a = 1;

		do {
			System.out.println(a);

			a++;
		} while (a <= 9);

		System.out.println("test\n");

		int x = 9;

		do {
			System.out.println(x);

			x--;
		} while (x >= 0);
	}
}

Nested do-while:
do {
	// instructions
	do {
		// instructions
	}while(condition);
}while(condition);

Difference between for loop and while loop:

If we know the boundaries like start and end then we use for loop.
ex: I want to print prime numbers between 1 to 100

If we do not know the boundaries like start and end then we use while loop.
ex: I want to print 100 prime numbers

Enhanced for loop:
------------------
It works arrays.

Syntax: 
for(variable : array)

Example code:
package com.array;

public class EnhancedForLoopExample {
	public static void main(String[] args) {

		int[] numbers = new int[12];

		System.out.println("Size: " + numbers.length);

		for (int i = 0; i < numbers.length; i++) {
			numbers[i] = i + 1;
		}
		for (int i : numbers) {
			System.out.println(i);
		}
	}
}

continue:
---------
continue is key word used to stop the current iteration from executing further instruction and Continue with next iteration.

package com.loop.continueex;

public class ContinueExample {
	public static void main(String[] args) {

		for (int a = 1; a <= 100; a++) {

			// I dont want to print 67
			if (a == 67) {
				continue;
			}
			System.out.println(a);
		}
	}
}

We can use continue in loops only.
We have to use continue conditionally to avoid unreachable code issue.

break:
------
break is a keyword and used to stop the loop from executing further completely.

Example code:
package com.loop.breakex;

public class BreakExample {
	public static void main(String[] args) {

		for (int a = 1; a <= 100; a++) {

			if (a == 51) {
				break;
			}

			System.out.println(a);
		}
	}
}

We can use break in loops, switch only.
We have to use break conditionally to avoid unreachable code issue.

Arrays:
-------
Array is collection of data of same type.
Based on the size of the array memory will be allocated.
Memory will be allocated in sequence memory locations and initialized with default values.

syntax:
datatype[] variableName = new datatype[sizeOfArray];

ex:
int[] numbers = new int[9];

Array works with index.
index start from 0 (zero) and end with (array size - 1)
ex:
int[] numbers = new int[9];
size: 9
start index: 0
end index: 8

Every array will given with one default property called "length". It determines size of the array.

syntax: array.length
ex: numbers.length

Example code:
package com.array;

public class NumberSystem {

	public static void main(String[] args) {
		int[] numbers = new int[12];

		System.out.println("Size: " + numbers.length);

		for (int i = 0; i < numbers.length; i++) {
			numbers[i] = i + 1;
		}

		for (int a = 0; a < numbers.length; a++) {
			int x = numbers[a];

			System.out.println(x);
		}

		System.out.println("Number: " + numbers[3]);
	}
}

19-JULY-2023
------------
Non-Primitive Predefined Data type:

String:
-------

String[] names = new String[3];

Example code:
package com.array;

public class StringExample {
	public static void main(String[] args) {

		String[] names = new String[4];

		names[0] = "Anil";
		names[1] = "Bharat";
		names[2] = "Chandu";
		names[3] = "Druv";

		for (int i = 0; i < names.length; i++) {
			System.out.println(names[i]);
		}
	}
}

Non-Primitive User defined Data type:

Student:
--------
Example code:
package com.array;

public class StudentExample {
	public static void main(String[] args) {

		Student[] students = new Student[3];

		Student s1 = new Student();
		s1.setRollNumber(1);
		s1.setName("Anil");
		s1.setAge(22);

		Student s2 = new Student();
		s2.setRollNumber(2);
		s2.setName("Bharat");
		s2.setAge(21);

		Student s3 = new Student();
		s3.setRollNumber(3);
		s3.setName("Chandu");
		s3.setAge(22);

		students[0] = s1;
		students[1] = s3;
		students[2] = s2;

		for (int i = 0; i < students.length; i++) {
			Student s = students[i];

			System.out.println(s.getRollNumber());
			System.out.println(s.getName());
			System.out.println(s.getAge());
			System.out.println();
		}
	}
}

20-JULY-2023
------------
One more way of creating array:
datatype[] array = new datatype[] {value1, value2, ...};
int[] numbers = new int[] { 1, 2, 4, 77, 5, 88 };

package com.array;

public class EnhancedForLoopExample {

	public static void main(String[] args) {

		int[] numbers = new int[] { 1, 2, 4, 77, 5, 88 };

		System.out.println("Size: " + numbers.length);

		for (int i : numbers) {
			System.out.println(i);
		}
	}
}

package com.array;

public class EnhancedForLoopExample {

	public static void main(String[] args) {

		String[] values = new String[] { "Anil", "Bharat", "Chandu" };

		System.out.println("Size: " + values.length);

		for (String i : values) {
			System.out.println(i);
		}
	}
}

java.lang package:
------------------
Object class has 9 methods as below

public class java.lang.Object {
  public java.lang.Object(); - Constructor
  public final native java.lang.Class<?> getClass();
  public native int hashCode();
  public boolean equals(java.lang.Object);
  protected native java.lang.Object clone();
  public java.lang.String toString();
  public final native void notify();
  public final native void notifyAll();
  public final void wait();
  public final native void wait(long);
  public final void wait(long, int);
  protected void finalize();
}

getClass(): it return Class object with meta data of the Class.
hashCode(): it returns the address of the object.
toString(): it returns string which contains class name and hash code by default.
equals(): to compare two objects equality.

package com.basics;

import java.lang.reflect.Field;
import java.lang.reflect.Method;

public class GetClassTest {

	public static void main(String[] args) {

		Student s = new Student();

		Class<? extends Student> sClass = s.getClass();

		System.out.println(sClass.getCanonicalName());
		System.out.println(sClass.getName());
		System.out.println(sClass.getPackageName());
		System.out.println(sClass.getSimpleName());

		Field[] declaredFields = sClass.getDeclaredFields();

		for (Field field : declaredFields) {
			System.out.println(field.getName());
		}

		Method[] declaredMethods = sClass.getDeclaredMethods();

		for (Method method : declaredMethods) {
			System.out.println(method.getName());
		}
	}
}

package com.basics;

public class HashCodeTest {
	public static void main(String[] args) {

		Student s = new Student();

		int hashCode = s.hashCode();

		System.out.println(hashCode);
	}
}

package com.basics;

public class ToStringExample {
	public static void main(String[] args) {

		Student s = new Student();

		System.out.println(s.toString());
	}
}

package com.basics;

public class EqualExample {
	public static void main(String[] args) {
		Student s1 = new Student();

		System.out.println(s1.equals(s1));

		Student s2 = new Student();

		System.out.println(s2.equals(s1));
	}
}

java.lang package:
Wrapper classes, String, Math, System, Class.

String class:
package com.basics;

public class StringExample {
	public static void main(String[] args) {

		String value = "Test"; // String constant pool - (not in heap)

		String name = new String("Anil"); // in Heap & String constant pool

		for (int i = 0; i < name.length(); i++) {

			char c = name.charAt(i);

			System.out.println(c);
		}

		String s = name.substring(2);

		System.out.println(s);
	}
}

package com.basics;

public class MathExample {
	public static void main(String[] args) {

		int min = Math.min(2, 4);

		System.out.println(min);

		int max = Math.max(2, 4);

		System.out.println(max);

		double pow = Math.pow(2, 4);

		System.out.println(pow);

		double sqrt = Math.sqrt(4);

		System.out.println(sqrt);
	}
}

package com.basics;

public class SystemExample {

	public static void main(String[] args) {
		System.out.println("test");
	}
}

package com.basics;

import java.lang.reflect.Field;
import java.lang.reflect.Method;

public class GetClassTest {

	public static void main(String[] args) {

		Student s = new Student();

		Class<? extends Student> sClass = s.getClass();

		System.out.println(sClass.getCanonicalName());
		System.out.println(sClass.getName());
		System.out.println(sClass.getPackageName());
		System.out.println(sClass.getSimpleName());

		Field[] declaredFields = sClass.getDeclaredFields();

		for (Field field : declaredFields) {
			System.out.println(field.getName());
		}

		Method[] declaredMethods = sClass.getDeclaredMethods();

		for (Method method : declaredMethods) {
			System.out.println(method.getName());
		}
	}
}






